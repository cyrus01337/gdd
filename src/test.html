<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>Gradis' Dungeon Delver</title>
        <style>
            body {
                font-family: "Courier New", Courier, monospace;
                display: flex;
                flex-direction: column;
                align-items: center;
                margin: 0;
                padding: 10px;
                background-color: #1a1a1a;
                color: #c0c0c0;
                touch-action: manipulation;
                line-height: 1.6;
            }
            .container {
                width: 100%;
                max-width: 600px;
                background-color: #0d0d0d;
                padding: 15px;
                border: 1px solid #333;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                margin-bottom: 10px;
            }
            h1,
            h2 {
                text-align: center;
                color: #ff6347; /* Tomato Red */
                margin-top: 0;
            }
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-bottom: 15px;
                font-size: 0.9em;
            }
            .stats-grid div {
                background-color: #222;
                padding: 8px;
                border-radius: 3px;
            }
            .stats-grid strong,
            .equipment-grid strong {
                color: #4682b4;
            }
            #player-gold {
                color: #ffd700;
            }

            .equipment-grid {
                display: grid;
                grid-template-columns: 1fr; /* Stack equipment items */
                gap: 5px;
                margin-top: 10px;
                font-size: 0.85em;
            }
            .equipment-grid div {
                background-color: #222;
                padding: 8px;
                border-radius: 3px;
                margin-bottom: 5px;
            }
            .equipment-grid div:last-child {
                margin-bottom: 0;
            }
            .equipment-grid .item-name {
                color: #9acd32;
            }
            .equipment-grid .item-bonus {
                color: #ffb6c1;
                font-size: 0.9em;
            }

            .rarity-Common {
                color: #bebebe;
            }
            .rarity-Uncommon {
                color: #1eff00;
            }
            .rarity-Rare {
                color: #00b0ff;
            }
            .rarity-Epic {
                color: #c700ff;
            }
            .rarity-Legendary {
                color: #ffa500;
            }
            .rarity-Mythic {
                color: #ff3c00;
            }
            .rarity-Divine {
                color: #ffdf00;
            }
            .rarity-Eternal {
                color: #00ffff;
            }
            .rarity-Immortal {
                color: #ff00ff;
            }
            .rarity-Transcendent {
                font-weight: bold;
                background: linear-gradient(
                    to right,
                    red,
                    orange,
                    yellow,
                    green,
                    blue,
                    indigo,
                    violet
                );
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
                animation: rainbow-text-animation 3s ease-in-out infinite;
                background-size: 400% 100%;
            }
            .elite-enemy {
                color: #ff6347; /* Tomato Red for elite names */
                font-weight: bold;
            }

            @keyframes rainbow-text-animation {
                0% {
                    background-position: 0% 50%;
                }
                50% {
                    background-position: 100% 50%;
                }
                100% {
                    background-position: 0% 50%;
                }
            }

            #enemy-info,
            #merchant-area {
                text-align: center;
                margin-bottom: 15px;
                padding: 10px;
                background-color: #2a2a2a;
                border-radius: 3px;
                min-height: 50px;
            }
            #enemy-info {
                background-color: #2a0000;
            }
            #merchant-title {
                font-size: 1.2em;
                color: #61dafb;
                margin-bottom: 10px;
            }
            .merchant-offer {
                padding: 8px;
                margin: 5px 0;
                border: 1px solid #444;
                border-radius: 3px;
                background-color: #333;
                font-size: 0.9em;
            }

            #enemy-name {
                font-size: 1.2em;
            }
            #enemy-hp {
                color: #ffcccb;
            }

            #log {
                background-color: #111;
                padding: 10px;
                height: 180px;
                overflow-y: auto;
                border: 1px solid #333;
                border-radius: 3px;
                margin-bottom: 15px;
                font-size: 0.85em;
            }
            #log p {
                margin: 0 0 5px 0;
                border-bottom: 1px dashed #222;
                padding-bottom: 3px;
            }
            #log p:last-child {
                border-bottom: none;
            }

            .actions {
                margin-bottom: 15px;
            }
            .actions button,
            .merchant-actions button,
            .modal-actions button {
                display: block;
                width: calc(100% - 10px);
                padding: 12px 5px;
                font-size: 1em;
                font-family: "Courier New", Courier, monospace;
                background-color: #363636;
                color: #c0c0c0;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                margin: 5px auto;
                transition:
                    background-color 0.2s,
                    color 0.2s;
            }
            .actions button:hover:not(:disabled),
            .merchant-actions button:hover:not(:disabled),
            .modal-actions button:hover:not(:disabled) {
                background-color: #4682b4;
                color: #fff;
            }
            .actions button:disabled,
            .merchant-actions button:disabled,
            .modal-actions button:disabled {
                background-color: #222;
                color: #555;
                cursor: not-allowed;
            }
            #game-over-screen {
                text-align: center;
                padding: 20px;
                background-color: rgba(0, 0, 0, 0.8);
                border-radius: 5px;
            }
            #game-over-screen h2 {
                color: #dc143c;
            }

            .modal-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 1000;
                justify-content: center;
                align-items: center;
            }
            .modal-content {
                background-color: #1e1e1e;
                padding: 20px;
                border-radius: 5px;
                border: 1px solid #444;
                text-align: center;
                width: 90%;
                max-width: 400px;
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
            }
            .modal-content p {
                margin-bottom: 15px;
                font-size: 1.1em;
            }
            .modal-actions {
                display: flex;
                justify-content: space-around;
                gap: 10px;
            }
            .modal-actions button {
                width: 45%;
                margin: 5px 0;
            }
            #confirm-purchase-button {
                background-color: #28a745;
            }
            #confirm-purchase-button:hover {
                background-color: #218838;
            }
            #cancel-purchase-button {
                background-color: #dc3545;
            }
            #cancel-purchase-button:hover {
                background-color: #c82333;
            }

            #help-button {
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-family: "Courier New", Courier, monospace;
                background-color: #363636;
                color: #c0c0c0;
                border: 1px solid #555;
                border-radius: 4px;
                cursor: pointer;
                z-index: 999;
                font-size: 0.9em;
            }
            #help-button:hover {
                background-color: #4682b4;
                color: #fff;
            }
            #shortcuts-list ul {
                list-style-type: disc;
                padding-left: 30px;
                margin-top: 2px;
                margin-bottom: 12px;
            }
            #shortcuts-list li {
                margin-bottom: 4px;
            }
            #shortcuts-list p > strong {
                color: #61dafb;
                font-size: 1.05em;
            }
            #shortcuts-list hr {
                border: 0;
                border-top: 1px dashed #444;
                margin: 15px 0;
            }
        </style>
    </head>
    <body>
        <h1>Gradis' Dungeon Delver</h1>
        <button id="help-button">Help (?)</button>

        <div class="container" id="player-stats-area">
            <h2>Player Stats</h2>
            <div class="stats-grid">
                <div>Level: <strong id="player-level">1</strong></div>
                <div>XP: <strong id="player-xp">0 / 100</strong></div>
                <div>HP: <strong id="player-hp">30 / 30</strong></div>
                <div>Base ATK: <strong id="player-base-attack">4</strong></div>
                <div>Base DEF: <strong id="player-base-defense">1</strong></div>
                <div>Gold: <strong id="player-gold">0</strong></div>
                <div>Total ATK: <strong id="player-total-attack">4</strong></div>
                <div>Total DEF: <strong id="player-total-defense">1</strong></div>
            </div>
            <div class="equipment-grid">
                <div>
                    Weapon: <span id="player-weapon-name" class="item-name">Crude Club</span>
                    <span id="player-weapon-bonus" class="item-bonus">(+1 ATK)</span>
                    <span id="player-weapon-rarity" class="rarity-Common">[Common]</span>
                </div>
                <div>
                    Armor: <span id="player-armor-name" class="item-name">Scavenged Hide</span>
                    <span id="player-armor-bonus" class="item-bonus">(+1 DEF)</span>
                    <span id="player-armor-rarity" class="rarity-Common">[Common]</span>
                </div>
                <div>
                    Accessory: <span id="player-accessory-name" class="item-name">None</span>
                    <span id="player-accessory-bonus" class="item-bonus"></span>
                    <span id="player-accessory-rarity" class="rarity-Common"></span>
                </div>
            </div>
        </div>

        <div class="container" id="enemy-area" style="display: none">
            <h2>Enemy</h2>
            <div id="enemy-info">
                <span id="enemy-name"></span> (<span id="enemy-hp"></span> HP)
            </div>
        </div>

        <div class="container" id="merchant-area" style="display: none">
            <h2 id="merchant-title">Wandering Merchant</h2>
            <div id="merchant-offer-1" class="merchant-offer">Offer 1...</div>
            <div id="merchant-offer-2" class="merchant-offer">Offer 2...</div>
            <div class="merchant-actions">
                <button id="buy-offer-1-button">Buy Offer 1</button>
                <button id="buy-offer-2-button">Buy Offer 2</button>
                <button id="leave-merchant-button">Continue Exploring</button>
            </div>
        </div>

        <div class="container actions">
            <button id="explore-button">Explore Dungeon</button>
            <button id="attack-button" style="display: none">Attack</button>
            <button id="defend-button" style="display: none">Defend (Reduces Dmg)</button>
            <button id="potion-button" style="display: none">
                Use Potion (<span id="potion-count-button">4</span>)
            </button>
        </div>

        <div class="container">
            <div id="log">
                <p>Welcome to the Dungeon! Click "Explore" to begin.</p>
            </div>
        </div>

        <div class="container" id="game-over-screen" style="display: none">
            <h2 id="game-over-message">Game Over!</h2>
            <button id="restart-button">Restart Game</button>
        </div>

        <div id="purchase-confirmation-modal" class="modal-overlay">
            <div class="modal-content">
                <p id="confirmation-message">Are you sure you want to purchase this item?</p>
                <div class="modal-actions">
                    <button id="confirm-purchase-button">Confirm</button>
                    <button id="cancel-purchase-button">Cancel</button>
                </div>
            </div>
        </div>

        <div id="help-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>Keyboard Shortcuts</h2>
                <div
                    id="shortcuts-list"
                    style="
                        text-align: left;
                        line-height: 1.6;
                        margin-top: 10px;
                        max-height: 60vh;
                        overflow-y: auto;
                    "
                >
                    <p><strong>Enter:</strong></p>
                    <ul>
                        <li>Confirm Purchase (in confirmation pop-up)</li>
                        <li>Restart Game (on Game Over screen)</li>
                        <li>Explore Dungeon (when available)</li>
                    </ul>
                    <p><strong>Backspace:</strong></p>
                    <ul>
                        <li>Cancel Purchase (in confirmation pop-up)</li>
                    </ul>
                    <p><strong>Spacebar:</strong> Attack (in combat)</p>
                    <p><strong>D:</strong> Defend (in combat)</p>
                    <p><strong>P:</strong> Use Potion (in combat)</p>
                    <p><strong>1:</strong> Select/Buy Merchant Offer 1</p>
                    <p><strong>2:</strong> Select/Buy Merchant Offer 2</p>
                    <p><strong>3:</strong> Leave Merchant</p>
                    <hr />
                    <p><strong>Esc:</strong> Close this Help window</p>
                </div>
                <div class="modal-actions" style="margin-top: 15px">
                    <button id="close-help-modal-button">Close</button>
                </div>
            </div>
        </div>

        <script>
            const GAME_CONSTANTS = {
                LOG_MAX_ENTRIES: 40,
                INITIAL_PLAYER_STATS: {
                    LEVEL: 1,
                    XP: 0,
                    XP_TO_NEXT_LEVEL: 65,
                    CURRENT_HP: 25,
                    MAX_HP: 25,
                    BASE_ATTACK: 3,
                    BASE_DEFENSE: 1,
                    POTIONS: 3,
                    MAX_POTIONS: 50,
                    GOLD: 0,
                    DEFAULT_WEAPON: {
                        name: "Old Stick",
                        type: "weapon",
                        bonus: 0,
                        rarity: "Common",
                        attackBonus: 0,
                        defenseBonus: 0,
                    },
                    DEFAULT_ARMOR: {
                        name: "Torn Shirt",
                        type: "armor",
                        bonus: 0,
                        rarity: "Common",
                    },
                    DEFAULT_ACCESSORY: {
                        name: "None",
                        type: "accessory",
                        rarity: "Common",
                        description: "No bonus",
                        bonuses: {},
                    },
                },
                POTION_HEAL_BASE_PERCENT: 0.45,
                POTION_HEAL_LEVEL_MULTIPLIER: 0.001,
                PLAYER_BASE_CRIT_CHANCE: 0.05,
                PLAYER_CRIT_CHANCE_LEVEL_MULTIPLIER: 0.003,
                PLAYER_BASE_CRIT_DAMAGE_MULTIPLIER: 1.75,
                PLAYER_CRIT_DAMAGE_LEVEL_MULTIPLIER: 0.005,
                ENEMY_BASE_CRIT_CHANCE: 0.12,
                ENEMY_CRIT_CHANCE_LEVEL_MULTIPLIER: 0.0005,
                ENEMY_BASE_CRIT_DAMAGE_MULTIPLIER: 1.5,
                ENEMY_CRIT_DAMAGE_LEVEL_MULTIPLIER: 0.002,
                EXPLORE_EVENT_THRESHOLDS: {
                    // Cumulative probabilities
                    LOST_COLLECTOR: 0.02,
                    POTION_CRATE: 0.04, // prev + 0.02
                    MERCHANT: 0.08, // prev + 0.04
                    STRAY_POTION: 0.125, // prev + 0.045
                    BLACKSMITH: 0.175, // prev + 0.05
                    REST_HOUSE: 0.25, // prev + 0.075
                    // ENEMY spawn is the remainder
                },
                BLACKSMITH_RARE_UPGRADE_CHANCE: 0.2,
                BLACKSMITH_UPGRADE_VALUES: {
                    RARE: [3, 4], // [Option1, Option2]
                    COMMON: [1, 2],
                },
                BLACKSMITH_UPGRADE_RARE_ROLL_THRESHOLD: 0.5, // Chance for Option1 vs Option2 if RARE
                BLACKSMITH_UPGRADE_COMMON_ROLL_THRESHOLD: 0.7, // Chance for Option1 vs Option2 if COMMON
                POTION_CRATE_MIN_FOUND: 3,
                POTION_CRATE_MAX_FOUND_EXCLUSIVE: 7, // Random will be from MIN to MAX-1
                LEVEL_UP_XP_MULTIPLIERS: [
                    // Sorted by minLevel descending
                    { minLevel: 26, multiplier: 1.37 },
                    { minLevel: 23, multiplier: 1.36 },
                    { minLevel: 20, multiplier: 1.35 },
                    { minLevel: 18, multiplier: 1.38 },
                    { minLevel: 12, multiplier: 1.48 },
                    { minLevel: 1, multiplier: 1.65 },
                ],
                LEVEL_UP_HP_GAIN: { BASE_PERCENT: 0.18, LEVEL_MULTIPLIER: 0.001, FLAT_BASE: 10 },
                LEVEL_UP_ATTACK_GAIN: {
                    BASE_PERCENT: 0.08,
                    LEVEL_MULTIPLIER: 0.0005,
                    EVEN_LEVEL_BONUS: 3,
                    ODD_LEVEL_BONUS: 2,
                    PER_4_LEVELS_BONUS: 1,
                },
                LEVEL_UP_DEFENSE_GAIN: {
                    BASE_PERCENT: 0.07,
                    LEVEL_MULTIPLIER: 0.0005,
                    PER_3_LEVELS_BONUS: 2,
                    OTHER_LEVELS_BONUS: 1,
                    PER_5_LEVELS_BONUS: 1,
                },
                MERCHANT_XP_POTION: {
                    BASE_COST_FACTOR: 0.12,
                    LEVEL_COST_FACTOR: 0.0035,
                    XP_MIN_PERCENT_OF_NEXT_LEVEL: 0.6,
                    XP_RANDOM_ADDITIONAL_PERCENT: 0.25,
                },
                MERCHANT_POTION_COST: { BASE: 10, PER_LEVEL: 1.2, PER_MAX_HP: 0.035 },
                ENEMY_SCALING: {
                    LEVEL_TIER_DIVISOR: 4,
                    HP_PER_LEVEL_ADVANTAGE_FACTOR: 0.055,
                    HP_FLAT_PER_PLAYER_LEVEL: 0.65,
                    ATK_PER_LEVEL_ADVANTAGE_FACTOR: 0.055,
                    ATK_FLAT_PER_PLAYER_LEVEL: 0.35,
                    DEF_PER_LEVEL_ADVANTAGE_FACTOR: 0.035,
                    DEF_FLAT_PER_PLAYER_LEVEL: 0.18,
                },
                ELITE_MODIFIERS: {
                    HP_MULTIPLIER: 1.75,
                    ATK_MULTIPLIER: 1.4,
                    DEF_MULTIPLIER: 1.4,
                    XP_MULTIPLIER: 2.5,
                    GOLD_MULTIPLIER: 2,
                    LOOT_CHANCE_MULTIPLIER: 1.5,
                    SPAWN_MIN_PLAYER_LEVEL: 15,
                    SPAWN_CHANCE: 0.15,
                },
                SPECIAL_BOSS_LOOT: {
                    WYRM_GUARDIAN: { ULTRA_CHANCE: 0.12, TRANSCENDENT_CHANCE: 0.007 },
                    HIGH_TIER_REGULAR: { ULTRA_CHANCE: 0.03 }, // For Dread Knight, Nether Sorc etc.
                    VOID_ETC_TRANSCENDENT_CHANCE: 0.004, // For Void Reaver, Infernal Jugg, Archlich
                },
                FINAL_BOSS_LOOT: {
                    POTIONS_GAINED_BASE: 5,
                    POTIONS_PER_5_PLAYER_LEVELS: 1,
                    HIGH_ITEM_COUNT_BASE: 1,
                    HIGH_ITEM_ADDITIONAL_CHANCE: 0.6,
                    ETERNAL_DROP_CHANCE: 0.5,
                    IMMORTAL_DROP_CHANCE: 0.35,
                    TRANSCENDENT_DROP_CHANCE: 0.2,
                },
                LOST_COLLECTOR_XP_REWARD: {
                    BASE_PERCENT_OF_NEXT_LEVEL: 0.3,
                    PER_LEVEL_PERCENT: 0.005,
                },
                LOST_COLLECTOR_GEAR_BONUS_BASE: 5,
                LOST_COLLECTOR_GEAR_BONUS_PER_4_LEVELS: 1,
            };

            let player;
            let currentEnemy = null;
            let inCombat = false;
            let firstEncounter = true;
            let inMerchantEncounter = false;
            let currentMerchantOffers = [];
            let pendingPurchaseAction = null;

            const accessories = [
                /* Accessory data remains the same */
                {
                    name: "Worn Locket",
                    type: "accessory",
                    rarity: "Common",
                    bonuses: { flatHp: 5 },
                    cost: 75,
                    description: "+5 Max HP",
                },
                {
                    name: "Cracked Ring",
                    type: "accessory",
                    rarity: "Common",
                    bonuses: { flatDefense: 1 },
                    cost: 90,
                    description: "+1 DEF",
                },
                {
                    name: "Lucky Charm",
                    type: "accessory",
                    rarity: "Uncommon",
                    bonuses: { goldFind: 0.05 },
                    cost: 200,
                    description: "+5.0% Gold Find",
                },
                {
                    name: "Apprentice's Ring",
                    type: "accessory",
                    rarity: "Uncommon",
                    bonuses: { flatAttack: 2 },
                    cost: 220,
                    description: "+2 ATK",
                },
                {
                    name: "Padded Belt",
                    type: "accessory",
                    rarity: "Uncommon",
                    bonuses: { flatHp: 12, flatDefense: 1 },
                    cost: 250,
                    description: "+12 Max HP, +1 DEF",
                },
                {
                    name: "Scholar's Monocle",
                    type: "accessory",
                    rarity: "Rare",
                    bonuses: { xpGain: 0.07 },
                    cost: 500,
                    description: "+7.0% XP Gain",
                },
                {
                    name: "Adept's Band",
                    type: "accessory",
                    rarity: "Rare",
                    bonuses: { critChance: 0.03 },
                    cost: 600,
                    description: "+3.0% Crit Chance",
                },
                {
                    name: "Berserker's Bracer",
                    type: "accessory",
                    rarity: "Rare",
                    bonuses: { flatAttack: 3, critDamage: 0.05 },
                    cost: 750,
                    description: "+3 ATK, +5.0% Crit DMG",
                },
                {
                    name: "Ring of Profiteering",
                    type: "accessory",
                    rarity: "Epic",
                    bonuses: { goldFind: 0.12, merchantDiscount: 0.05 },
                    cost: 1500,
                    description: "+12.0% Gold Find, 5.0% Merchant Discount",
                },
                {
                    name: "Shadowfang Pendant",
                    type: "accessory",
                    rarity: "Epic",
                    bonuses: { critChance: 0.05, critDamage: 0.1 },
                    cost: 1800,
                    description: "+5.0% Crit Chance, +10.0% Crit DMG",
                },
                {
                    name: "Guardian's Sigil",
                    type: "accessory",
                    rarity: "Epic",
                    bonuses: { flatHp: 30, flatDefense: 5, potionEffectiveness: 0.1 },
                    cost: 2000,
                    description: "+30 Max HP, +5 DEF, +10.0% Potion Heal",
                },
            ];
            const enemies = [
                /* Enemy data remains the same */
                // Early Game (Player Lvl 1-5)
                {
                    name: "Slime",
                    baseHp: 10,
                    baseAttack: 5,
                    baseDefense: 0,
                    xpYield: 12,
                    goldDropRange: [8, 15],
                    lootTable: [{ type: "armor", chance: 0.25, rarities: ["Common"] }],
                    potionDropChance: 0.08,
                },
                {
                    name: "Bat",
                    baseHp: 8,
                    baseAttack: 6,
                    baseDefense: 0,
                    xpYield: 10,
                    goldDropRange: [6, 12],
                    lootTable: [{ type: "weapon", chance: 0.15, rarities: ["Common"] }],
                    potionDropChance: 0.04,
                },
                {
                    name: "Skeleton",
                    baseHp: 20,
                    baseAttack: 8,
                    baseDefense: 1,
                    xpYield: 25,
                    goldDropRange: [15, 25],
                    lootTable: [
                        { type: "weapon", chance: 0.4, rarities: ["Common"] },
                        { type: "armor", chance: 0.25, rarities: ["Common"] },
                        {
                            type: "weapon",
                            chance: 0.02,
                            isUnique: true,
                            uniqueName: "Femur Club",
                            uniqueItemType: "weapon",
                            uniqueBonus: 4,
                            uniqueRarity: "Uncommon",
                        },
                        {
                            type: "armor",
                            chance: 0.02,
                            isUnique: true,
                            uniqueName: "Ribcage Guard",
                            uniqueItemType: "armor",
                            uniqueBonus: 5,
                            uniqueRarity: "Uncommon",
                        },
                    ],
                    potionDropChance: 0.12,
                },
                {
                    name: "Goblin Grunt",
                    baseHp: 20,
                    baseAttack: 5,
                    baseDefense: 0,
                    xpYield: 30,
                    goldDropRange: [18, 28],
                    lootTable: [
                        { type: "weapon", chance: 0.6, rarities: ["Common"] },
                        { type: "armor", chance: 0.4, rarities: ["Common"] },
                    ],
                    potionDropChance: 0.3,
                },
                {
                    name: "Cave Spider",
                    baseHp: 18,
                    baseAttack: 9,
                    baseDefense: 0,
                    xpYield: 35,
                    goldDropRange: [20, 35],
                    lootTable: [
                        { type: "weapon", chance: 0.55, rarities: ["Common", "Uncommon"] },
                        { type: "armor", chance: 0.35, rarities: ["Common"] },
                    ],
                    potionDropChance: 0.25,
                },
                {
                    name: "Orc Scout",
                    baseHp: 45,
                    baseAttack: 13,
                    baseDefense: 2,
                    xpYield: 60,
                    goldDropRange: [30, 50],
                    lootTable: [
                        { type: "weapon", chance: 0.7, rarities: ["Common", "Uncommon"] },
                        { type: "armor", chance: 0.5, rarities: ["Common", "Uncommon"] },
                    ],
                    potionDropChance: 0.28,
                },
                {
                    name: "Dire Wolf",
                    baseHp: 55,
                    baseAttack: 18,
                    baseDefense: 2,
                    xpYield: 75,
                    goldDropRange: [40, 65],
                    lootTable: [
                        { type: "weapon", chance: 0.65, rarities: ["Uncommon", "Rare"] },
                        { type: "armor", chance: 0.5, rarities: ["Uncommon"] },
                        {
                            type: "armor",
                            chance: 0.02,
                            isUnique: true,
                            uniqueName: "Wolf-Fur Cloak",
                            uniqueItemType: "armor",
                            uniqueBonus: 15,
                            uniqueRarity: "Rare",
                        },
                        {
                            type: "weapon",
                            chance: 0.01,
                            isUnique: true,
                            uniqueName: "Wolf-Tooth Knife",
                            uniqueItemType: "weapon",
                            uniqueBonus: 18,
                            uniqueRarity: "Legendary",
                        },
                    ],
                    potionDropChance: 0.22,
                },
                {
                    name: "Stone Golem",
                    baseHp: 120,
                    baseAttack: 20,
                    baseDefense: 8,
                    xpYield: 130,
                    goldDropRange: [60, 100],
                    lootTable: [
                        { type: "weapon", chance: 0.6, rarities: ["Rare", "Epic"] },
                        { type: "armor", chance: 0.6, rarities: ["Uncommon", "Rare", "Epic"] },
                        {
                            type: "weapon",
                            chance: 0.025,
                            isUnique: true,
                            uniqueName: "Golem Heartstone",
                            uniqueItemType: "weapon",
                            uniqueBonusType: "hybrid",
                            attackBonus: 10,
                            defenseBonus: 3,
                            uniqueRarity: "Rare",
                        },
                        {
                            type: "armor",
                            chance: 0.025,
                            isUnique: true,
                            uniqueName: "Petrified Plate",
                            uniqueItemType: "armor",
                            uniqueBonus: 17,
                            uniqueRarity: "Epic",
                        },
                    ],
                    potionDropChance: 0.18,
                },
                {
                    name: "Ogre Brute",
                    baseHp: 150,
                    baseAttack: 25,
                    baseDefense: 7,
                    xpYield: 160,
                    goldDropRange: [75, 120],
                    lootTable: [
                        { type: "weapon", chance: 0.75, rarities: ["Uncommon", "Rare", "Epic"] },
                        { type: "armor", chance: 0.6, rarities: ["Uncommon", "Rare"] },
                        {
                            type: "weapon",
                            chance: 0.03,
                            isUnique: true,
                            uniqueName: "Ogre's Jaw-Mace",
                            uniqueItemType: "weapon",
                            uniqueBonus: 11,
                            uniqueRarity: "Rare",
                        },
                    ],
                    potionDropChance: 0.18,
                },
                {
                    name: "Deep Goblin Shaman",
                    baseHp: 100,
                    baseAttack: 28,
                    baseDefense: 3,
                    xpYield: 150,
                    goldDropRange: [80, 130],
                    lootTable: [
                        { type: "weapon", chance: 0.7, rarities: ["Uncommon", "Rare", "Epic"] },
                        { type: "armor", chance: 0.5, rarities: ["Uncommon", "Rare"] },
                    ],
                    potionDropChance: 0.32,
                },
                {
                    name: "Minotaur Charger",
                    baseHp: 220,
                    baseAttack: 42,
                    baseDefense: 12,
                    xpYield: 380,
                    goldDropRange: [150, 250],
                    lootTable: [
                        { type: "weapon", chance: 0.8, rarities: ["Rare", "Epic", "Legendary"] },
                        { type: "armor", chance: 0.65, rarities: ["Rare", "Epic", "Legendary"] },
                    ],
                    potionDropChance: 0.23,
                },
                {
                    name: "Wraith",
                    baseHp: 180,
                    baseAttack: 48,
                    baseDefense: 8,
                    xpYield: 350,
                    goldDropRange: [170, 280],
                    lootTable: [
                        { type: "weapon", chance: 0.75, rarities: ["Rare", "Epic", "Legendary"] },
                        { type: "armor", chance: 0.55, rarities: ["Rare", "Epic", "Legendary"] },
                    ],
                    potionDropChance: 0.18,
                },
                {
                    name: "Dread Knight",
                    baseHp: 380,
                    baseAttack: 50,
                    baseDefense: 25,
                    xpYield: 700,
                    goldDropRange: [300, 500],
                    lootTable: [
                        { type: "weapon", chance: 0.75, rarities: ["Epic", "Legendary", "Mythic"] },
                        { type: "armor", chance: 0.7, rarities: ["Epic", "Legendary", "Mythic"] },
                    ],
                    potionDropChance: 0.38,
                },
                {
                    name: "Nether Sorcerer",
                    baseHp: 320,
                    baseAttack: 60,
                    baseDefense: 15,
                    xpYield: 650,
                    goldDropRange: [330, 550],
                    lootTable: [
                        { type: "weapon", chance: 0.75, rarities: ["Epic", "Legendary", "Mythic"] },
                        { type: "armor", chance: 0.65, rarities: ["Epic", "Legendary", "Mythic"] },
                    ],
                    potionDropChance: 0.33,
                },
                {
                    name: "Void Reaver",
                    baseHp: 250,
                    baseAttack: 72,
                    baseDefense: 18,
                    xpYield: 1100,
                    goldDropRange: [400, 650],
                    ignoresDefense: true,
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.55,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                        {
                            type: "armor",
                            chance: 0.55,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                        { type: "weapon", chance: 0.004, rarities: ["Transcendent"] },
                    ],
                    potionDropChance: 0.28,
                },
                {
                    name: "Abyssal Behemoth",
                    baseHp: 600,
                    baseAttack: 65,
                    baseDefense: 35,
                    xpYield: 1200,
                    goldDropRange: [400, 670],
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.7,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                        { type: "armor", chance: 0.7, rarities: ["Legendary", "Mythic", "Divine"] },
                    ],
                    potionDropChance: 0.48,
                },
                {
                    name: "Aspect of Shadow",
                    baseHp: 480,
                    baseAttack: 80,
                    baseDefense: 22,
                    xpYield: 1150,
                    goldDropRange: [430, 700],
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.7,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                        {
                            type: "armor",
                            chance: 0.65,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                    ],
                    potionDropChance: 0.38,
                },
                {
                    name: "Infernal Juggernaut",
                    baseHp: 850,
                    baseAttack: 85,
                    baseDefense: 42,
                    xpYield: 2000,
                    goldDropRange: [600, 1000],
                    lootTable: [
                        { type: "weapon", chance: 0.75, rarities: ["Mythic", "Divine", "Eternal"] },
                        { type: "armor", chance: 0.75, rarities: ["Mythic", "Divine", "Eternal"] },
                    ],
                    potionDropChance: 0.58,
                },
                {
                    name: "Archlich Channeler",
                    baseHp: 700,
                    baseAttack: 100,
                    baseDefense: 32,
                    xpYield: 1950,
                    goldDropRange: [630, 1050],
                    lootTable: [
                        { type: "weapon", chance: 0.75, rarities: ["Mythic", "Divine", "Eternal"] },
                        { type: "armor", chance: 0.7, rarities: ["Mythic", "Divine", "Eternal"] },
                    ],
                    potionDropChance: 0.48,
                },
                {
                    name: "Ancient Wyrm",
                    baseHp: 700,
                    baseAttack: 55,
                    baseDefense: 22,
                    xpYield: 1600,
                    goldDropRange: [800, 1300],
                    isSpecial: true,
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.75,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                        {
                            type: "armor",
                            chance: 0.75,
                            rarities: ["Legendary", "Mythic", "Divine"],
                        },
                    ],
                },
                {
                    name: "Dungeon Guardian",
                    baseHp: 620,
                    baseAttack: 50,
                    baseDefense: 25,
                    xpYield: 1400,
                    goldDropRange: [750, 1200],
                    isSpecial: true,
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.9,
                            rarities: ["Epic", "Legendary", "Mythic", "Divine"],
                        },
                        {
                            type: "armor",
                            chance: 0.9,
                            rarities: ["Epic", "Legendary", "Mythic", "Divine"],
                        },
                    ],
                },
                {
                    name: "Celestial Paladin",
                    baseHp: 2000,
                    baseAttack: 95,
                    baseDefense: 65,
                    xpYield: 7500,
                    goldDropRange: [1400, 2400],
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.8,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.8,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "weapon",
                            chance: 0.15,
                            rarities: ["Transcendent"],
                            isForgable: true,
                        },
                    ],
                    potionDropChance: 0.68,
                },
                {
                    name: "Void Ascendant",
                    baseHp: 1100,
                    baseAttack: 110,
                    baseDefense: 45,
                    xpYield: 6800,
                    goldDropRange: [1700, 2900],
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.8,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.8,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.15,
                            rarities: ["Transcendent"],
                            isForgable: true,
                        },
                    ],
                    potionDropChance: 0.68,
                },
                {
                    name: "Chronomancer Adept",
                    baseHp: 2500,
                    baseAttack: 150,
                    baseDefense: 40,
                    xpYield: 50000,
                    goldDropRange: [2500, 5000],
                    timeWarpHealChance: 0.1,
                    timeWarpAttackChance: 0.1,
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.6,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.6,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "weapon",
                            chance: 0.25,
                            rarities: ["Transcendent"],
                            isForgable: true,
                        },
                    ],
                    potionDropChance: 0.75,
                },
                {
                    name: "Corrupted Treant",
                    baseHp: 2700,
                    baseAttack: 90,
                    baseDefense: 70,
                    xpYield: 8000,
                    goldDropRange: [1600, 2800],
                    lifeLeechMultiplier: 0.3,
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.8,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.8,
                            rarities: ["Divine", "Eternal", "Immortal"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.12,
                            rarities: ["Transcendent"],
                            isForgable: true,
                        },
                    ],
                    potionDropChance: 0.73,
                },
                {
                    name: "Reality Sculptor",
                    baseHp: 3200,
                    baseAttack: 135,
                    baseDefense: 75,
                    xpYield: 14500,
                    goldDropRange: [2400, 3900],
                    lootTable: [
                        {
                            type: "weapon",
                            chance: 0.9,
                            rarities: ["Eternal", "Immortal", "Transcendent"],
                            isForgable: true,
                        },
                        {
                            type: "armor",
                            chance: 0.9,
                            rarities: ["Eternal", "Immortal", "Transcendent"],
                            isForgable: true,
                        },
                    ],
                    potionDropChance: 0.78,
                },
                {
                    name: "The Nether Tyrant",
                    baseHp: 3500,
                    baseAttack: 140,
                    baseDefense: 60,
                    xpYield: 15000,
                    isFinalBoss: true,
                    goldDropRange: [3000, 5500],
                    lootTable: [],
                }, // Loot for final boss is handled specially
                {
                    name: "Lost Collector",
                    isSpecial: true,
                    baseHp: 75,
                    baseAttack: 1,
                    baseDefense: 5,
                    goldDropRange: [500, 1000],
                }, // XP and other loot handled specially
            ];
            const itemStatsByRarity = {
                /* This data remains the same */
                Common: {
                    weaponBonus: [1, 3],
                    armorBonus: [1, 3],
                    namePrefixes: ["Rusty", "Worn", "Basic", "Crude", "Simple"],
                },
                Uncommon: {
                    weaponBonus: [4, 7],
                    armorBonus: [4, 7],
                    namePrefixes: ["Decent", "Polished", "Sturdy", "Fine", "Soldier's"],
                },
                Rare: {
                    weaponBonus: [8, 12],
                    armorBonus: [8, 12],
                    namePrefixes: ["Superior", "Engraved", "Reinforced", "Knight's", "Adept's"],
                },
                Epic: {
                    weaponBonus: [13, 18],
                    armorBonus: [13, 18],
                    namePrefixes: ["Epic", "Masterwork", "Exquisite", "Champion's", "Heroic"],
                },
                Legendary: {
                    weaponBonus: [19, 25],
                    armorBonus: [19, 25],
                    namePrefixes: ["Legendary", "Fabled", "Artifact", "Dragon's", "Titan's"],
                },
                Mythic: {
                    weaponBonus: [26, 35],
                    armorBonus: [26, 35],
                    namePrefixes: ["Mythic", "Primordial", "Void-Touched", "Archon's", "Sovereign"],
                },
                Divine: {
                    weaponBonus: [36, 49],
                    armorBonus: [36, 49],
                    namePrefixes: ["Divine", "Blessed", "Sacred", "Angelic", "Hallowed"],
                },
                Eternal: {
                    weaponBonus: [50, 64],
                    armorBonus: [50, 64],
                    namePrefixes: ["Eternal", "Timeless", "Cosmic", "Starforged", "Infinite"],
                },
                Immortal: {
                    weaponBonus: [65, 80],
                    armorBonus: [65, 80],
                    namePrefixes: [
                        "Immortal",
                        "God-Slayer's",
                        "Unending",
                        "Reality-Render's",
                        "Apex",
                    ],
                },
                Transcendent: {
                    weaponBonus: [90, 110],
                    armorBonus: [90, 110],
                    namePrefixes: [
                        "Transcendent",
                        "Unfathomable",
                        "Beyond",
                        "Perfected",
                        "Singularity's",
                    ],
                },
            };
            const baseItemTypes = {
                /* This data remains the same */
                weapon: [
                    "Dagger",
                    "Shortsword",
                    "Mace",
                    "War Axe",
                    "Longspear",
                    "Greatsword",
                    "Warhammer",
                    "Katana",
                    "Trident",
                    "Scythe",
                    "Battle Staff",
                    "Morning Star",
                    "Glaive",
                    "Rapier",
                    "Flail",
                    "Longbow",
                    "Cestus",
                    "Maul",
                    "Kris",
                    "Claymore",
                    "Bastard Sword",
                    "War Scythe",
                ],
                armor: [
                    "Rags",
                    "Leather Tunic",
                    "Chain Vest",
                    "Scale Armor",
                    "Plate Cuirass",
                    "Full Helm",
                    "Kite Shield",
                    "Splint Mail",
                    "Dragonscale Vest",
                    "Obsidian Plate",
                    "Mystic Robes",
                    "Tower Shield",
                    "Barbarian Hide",
                    "Elven Chain",
                    "Warlock's Cowl",
                    "Knight's Greaves",
                    "Aegis",
                    "Spiked Shield",
                    "Shadow Weave",
                    "Demon Hide",
                ],
            };

            // DOM Element References (using const)
            const playerLevelEl = document.getElementById("player-level");
            const playerXpEl = document.getElementById("player-xp");
            const playerHpEl = document.getElementById("player-hp");
            const playerBaseAttackEl = document.getElementById("player-base-attack");
            const playerBaseDefenseEl = document.getElementById("player-base-defense");
            const playerGoldEl = document.getElementById("player-gold");
            const playerTotalAttackEl = document.getElementById("player-total-attack");
            const playerTotalDefenseEl = document.getElementById("player-total-defense");
            const potionCountButtonEl = document.getElementById("potion-count-button");
            const playerWeaponNameEl = document.getElementById("player-weapon-name");
            const playerWeaponBonusEl = document.getElementById("player-weapon-bonus");
            const playerWeaponRarityEl = document.getElementById("player-weapon-rarity");
            const playerArmorNameEl = document.getElementById("player-armor-name");
            const playerArmorBonusEl = document.getElementById("player-armor-bonus");
            const playerArmorRarityEl = document.getElementById("player-armor-rarity");
            const playerAccessoryNameEl = document.getElementById("player-accessory-name");
            const playerAccessoryBonusEl = document.getElementById("player-accessory-bonus");
            const playerAccessoryRarityEl = document.getElementById("player-accessory-rarity");

            const enemyAreaEl = document.getElementById("enemy-area");
            const enemyNameEl = document.getElementById("enemy-name");
            const enemyHpEl = document.getElementById("enemy-hp");
            const merchantAreaEl = document.getElementById("merchant-area");
            const merchantOffer1El = document.getElementById("merchant-offer-1");
            const merchantOffer2El = document.getElementById("merchant-offer-2");
            const buyOffer1Button = document.getElementById("buy-offer-1-button");
            const buyOffer2Button = document.getElementById("buy-offer-2-button");
            const leaveMerchantButton = document.getElementById("leave-merchant-button");
            const logEl = document.getElementById("log");
            const exploreButton = document.getElementById("explore-button");
            const attackButton = document.getElementById("attack-button");
            const defendButton = document.getElementById("defend-button");
            const potionButton = document.getElementById("potion-button");
            const gameOverScreenEl = document.getElementById("game-over-screen");
            const gameOverMessageEl = document.getElementById("game-over-message");
            const restartButton = document.getElementById("restart-button");
            const purchaseConfirmationModalEl = document.getElementById(
                "purchase-confirmation-modal",
            );
            const confirmationMessageEl = document.getElementById("confirmation-message");
            const confirmPurchaseButtonEl = document.getElementById("confirm-purchase-button");
            const cancelPurchaseButtonEl = document.getElementById("cancel-purchase-button");
            const helpButton = document.getElementById("help-button");
            const helpModalEl = document.getElementById("help-modal");
            const closeHelpModalButtonEl = document.getElementById("close-help-modal-button");

            function addLog(message) {
                const p = document.createElement("p");
                p.innerHTML = message; // Using innerHTML as messages can contain HTML styling
                logEl.insertBefore(p, logEl.firstChild);
                if (logEl.children.length > GAME_CONSTANTS.LOG_MAX_ENTRIES) {
                    logEl.removeChild(logEl.lastChild);
                }
            }

            function updateAccessoryDescription(accessory) {
                if (!accessory || accessory.name === "None" || !accessory.bonuses) {
                    accessory.description = "No bonus";
                    return;
                }
                let parts = []; // 'let' because it's an accumulating array
                for (const key in accessory.bonuses) {
                    const value = accessory.bonuses[key];
                    if (
                        value === 0 &&
                        !["flatHp", "flatAttack", "flatDefense"].includes(key) &&
                        !(value === 0 && key === "critChance" && accessory.name !== "None")
                    )
                        continue;
                    switch (key) {
                        case "flatHp":
                            parts.push(`+${value} Max HP`);
                            break;
                        case "flatAttack":
                            parts.push(`+${value} ATK`);
                            break;
                        case "flatDefense":
                            parts.push(`+${value} DEF`);
                            break;
                        case "goldFind":
                            parts.push(`+${(value * 100).toFixed(1)}% Gold Find`);
                            break;
                        case "xpGain":
                            parts.push(`+${(value * 100).toFixed(1)}% XP Gain`);
                            break;
                        case "critChance":
                            parts.push(`+${(value * 100).toFixed(1)}% Crit Chance`);
                            break;
                        case "critDamage":
                            parts.push(`+${(value * 100).toFixed(1)}% Crit DMG`);
                            break;
                        case "merchantDiscount":
                            parts.push(`${(value * 100).toFixed(1)}% Merchant Discount`);
                            break;
                        case "potionEffectiveness":
                            parts.push(`+${(value * 100).toFixed(1)}% Potion Heal`);
                            break;
                        case "potionDropChance":
                            parts.push(`+${(value * 100).toFixed(1)}% Potion Drop`);
                            break;
                        default:
                            parts.push(`${key.replace(/([A-Z])/g, " $1")}: ${value}`);
                    }
                }
                accessory.description = parts.join(", ") || "No notable bonuses";
                if (accessory.name === "None") accessory.description = "No bonus";
            }

            function updatePlayerStatsUI() {
                playerLevelEl.textContent = player.level;
                playerXpEl.textContent = `${player.xp.toLocaleString()} / ${player.xpToNextLevel.toLocaleString()}`;
                playerBaseAttackEl.textContent = player.baseAttack;
                playerBaseDefenseEl.textContent = player.baseDefense;
                playerGoldEl.textContent = player.gold.toLocaleString();
                potionCountButtonEl.textContent = player.potions;

                const acc = player.accessory;
                if (playerAccessoryNameEl) {
                    playerAccessoryNameEl.textContent = acc.name;
                    playerAccessoryBonusEl.textContent = acc.description
                        ? `(${acc.description})`
                        : "";
                    playerAccessoryRarityEl.textContent = acc.rarity ? `[${acc.rarity}]` : "";
                    playerAccessoryRarityEl.className = acc.rarity
                        ? `rarity-${acc.rarity}`
                        : "rarity-Common";
                }

                const totalAttack =
                    player.baseAttack +
                    player.weapon.bonus +
                    (player.weapon.attackBonus || 0) +
                    ((acc && acc.bonuses && acc.bonuses.flatAttack) || 0);
                const totalDefense =
                    player.baseDefense +
                    player.armor.bonus +
                    (player.weapon.defenseBonus || 0) +
                    ((acc && acc.bonuses && acc.bonuses.flatDefense) || 0);
                playerTotalAttackEl.textContent = totalAttack;
                playerTotalDefenseEl.textContent = totalDefense;
                playerHpEl.textContent = `${player.currentHp} / ${player.maxHp}`;

                playerWeaponNameEl.textContent = player.weapon.name;
                let weaponBonusText = `(+${player.weapon.bonus + (player.weapon.attackBonus || 0)} ATK`;
                if (player.weapon.defenseBonus) {
                    weaponBonusText += `, +${player.weapon.defenseBonus} DEF`;
                }
                weaponBonusText += `)`;
                playerWeaponBonusEl.textContent = weaponBonusText;
                playerWeaponRarityEl.textContent = `[${player.weapon.rarity}]`;
                playerWeaponRarityEl.className = `rarity-${player.weapon.rarity}`;

                playerArmorNameEl.textContent = player.armor.name;
                playerArmorBonusEl.textContent = `(+${player.armor.bonus} DEF)`;
                playerArmorRarityEl.textContent = `[${player.armor.rarity}]`;
                playerArmorRarityEl.className = `rarity-${player.armor.rarity}`;

                potionButton.disabled =
                    player.potions <= 0 || player.currentHp === player.maxHp || !inCombat;
                if (inMerchantEncounter) {
                    updateMerchantUI();
                }
            }

            function updateEnemyStatsUI() {
                if (currentEnemy) {
                    enemyNameEl.innerHTML = currentEnemy.isElite
                        ? `<span class="elite-enemy">${currentEnemy.name}</span>`
                        : `<strong>${currentEnemy.name}</strong>`; // innerHTML for styling
                    enemyHpEl.textContent = currentEnemy.currentHp;
                    enemyAreaEl.style.display = "block";
                } else {
                    enemyAreaEl.style.display = "none";
                }
            }

            function toggleCombatUI(isCombat) {
                inCombat = isCombat;
                exploreButton.style.display = isCombat || inMerchantEncounter ? "none" : "block";
                attackButton.style.display = isCombat ? "block" : "none";
                defendButton.style.display = isCombat ? "block" : "none";
                potionButton.style.display = isCombat ? "block" : "none";
                if (isCombat) merchantAreaEl.style.display = "none";
                if (!isCombat) player.isDefending = false;
                updatePlayerStatsUI();
            }

            function toggleMerchantUI(isMerchant) {
                inMerchantEncounter = isMerchant;
                exploreButton.style.display = isMerchant || inCombat ? "none" : "block";
                merchantAreaEl.style.display = isMerchant ? "block" : "none";
                if (isMerchant) {
                    attackButton.style.display = "none";
                    defendButton.style.display = "none";
                    potionButton.style.display = "none";
                    enemyAreaEl.style.display = "none";
                }
            }

            function generateItem(itemType, possibleRarities, uniqueItemData = null) {
                if (uniqueItemData && uniqueItemData.isUnique) {
                    return {
                        name: uniqueItemData.uniqueName,
                        type: uniqueItemData.uniqueItemType,
                        bonus:
                            uniqueItemData.uniqueBonusType === "hybrid" &&
                            uniqueItemData.uniqueItemType === "weapon"
                                ? 0
                                : uniqueItemData.uniqueBonus || 0,
                        attackBonus:
                            uniqueItemData.uniqueBonusType === "hybrid" &&
                            uniqueItemData.uniqueItemType === "weapon"
                                ? uniqueItemData.attackBonus
                                : uniqueItemData.uniqueItemType === "weapon" &&
                                    !uniqueItemData.uniqueBonusType
                                  ? uniqueItemData.uniqueBonus
                                  : 0,
                        defenseBonus:
                            uniqueItemData.uniqueBonusType === "hybrid" &&
                            uniqueItemData.uniqueItemType === "weapon"
                                ? uniqueItemData.defenseBonus
                                : 0,
                        rarity: uniqueItemData.uniqueRarity,
                    };
                }
                const randomRarityPick =
                    possibleRarities[Math.floor(Math.random() * possibleRarities.length)];
                const rarity = itemStatsByRarity[randomRarityPick] ? randomRarityPick : "Common";
                const rarityInfo = itemStatsByRarity[rarity];
                let bonusRange =
                    itemType === "weapon" ? rarityInfo.weaponBonus : rarityInfo.armorBonus;
                if (!bonusRange) bonusRange = [1, 1]; // Fallback
                const bonus =
                    bonusRange[0] + Math.floor(Math.random() * (bonusRange[1] - bonusRange[0] + 1));
                const baseName =
                    baseItemTypes[itemType][
                        Math.floor(Math.random() * baseItemTypes[itemType].length)
                    ];
                const prefix =
                    rarityInfo.namePrefixes[
                        Math.floor(Math.random() * rarityInfo.namePrefixes.length)
                    ];
                return {
                    name: `${prefix} ${baseName}`,
                    type: itemType,
                    bonus: bonus,
                    rarity: rarity,
                    attackBonus: 0,
                    defenseBonus: 0,
                };
            }

            function tryEquipItem(newItem) {
                let equipped = false; // 'let' as it's conditionally changed
                newItem.bonus = newItem.bonus || 0;
                newItem.attackBonus = newItem.attackBonus || 0;
                newItem.defenseBonus = newItem.defenseBonus || 0;

                if (newItem.type === "weapon") {
                    const newWeaponEffectiveAttack =
                        (newItem.attackBonus || 0) +
                        (newItem.bonus && !(newItem.attackBonus > 0 && newItem.defenseBonus > 0)
                            ? newItem.bonus
                            : 0);
                    const currentWeaponEffectiveAttack =
                        (player.weapon.attackBonus || 0) +
                        (player.weapon.bonus &&
                        !(player.weapon.attackBonus > 0 && player.weapon.defenseBonus > 0)
                            ? player.weapon.bonus
                            : 0);
                    const newWeaponDefense = newItem.defenseBonus || 0;
                    const currentWeaponDefense = player.weapon.defenseBonus || 0;

                    if (
                        newWeaponEffectiveAttack > currentWeaponEffectiveAttack ||
                        (newWeaponEffectiveAttack === currentWeaponEffectiveAttack &&
                            newWeaponDefense > currentWeaponDefense)
                    ) {
                        player.weapon = newItem;
                        addLog(
                            `Equipped new weapon: <span class="rarity-${newItem.rarity}">${newItem.name}</span> (+${newWeaponEffectiveAttack} ATK${newWeaponDefense > 0 ? `, +${newWeaponDefense} DEF` : ""})!`,
                        );
                        equipped = true;
                    }
                } else if (newItem.type === "armor") {
                    if (newItem.bonus > player.armor.bonus) {
                        player.armor = newItem;
                        addLog(
                            `Equipped new armor: <span class="rarity-${newItem.rarity}">${newItem.name}</span> (+${newItem.bonus} DEF)!`,
                        );
                        equipped = true;
                    }
                }
                if (!equipped) {
                    let itemStatsLog = "";
                    if (newItem.type === "weapon") {
                        let effectiveNewAtk =
                            (newItem.attackBonus || 0) +
                            (newItem.bonus && !(newItem.attackBonus > 0 && newItem.defenseBonus > 0)
                                ? newItem.bonus
                                : 0);
                        itemStatsLog = `+${effectiveNewAtk} ATK`;
                        if (newItem.defenseBonus) itemStatsLog += `, +${newItem.defenseBonus} DEF`;
                    } else {
                        itemStatsLog = `+${newItem.bonus} DEF`;
                    }
                    addLog(
                        `Found <span class="rarity-${newItem.rarity}">${newItem.name}</span> (${itemStatsLog}), but your current gear is better or similar.`,
                    );
                }
                updatePlayerStatsUI();
            }

            function findRestHouse() {
                player.currentHp = player.maxHp;
                addLog(
                    "You stumble across a welcoming house and rest for a while. <strong>Your HP has been fully restored!</strong>",
                );
                const houseLootRoll = Math.random();
                let itemFoundInHouse = false;
                let itemRarity; // 'let' because it's conditionally assigned
                const itemType = Math.random() < 0.5 ? "weapon" : "armor";

                // Determine item rarity based on player level
                if (player.level < 5) {
                    if (houseLootRoll < 0.05) itemRarity = "Uncommon";
                    else if (houseLootRoll < 0.3) itemRarity = "Common";
                } else if (player.level < 10) {
                    if (houseLootRoll < 0.05) itemRarity = "Rare";
                    else if (houseLootRoll < 0.2) itemRarity = "Uncommon";
                    else if (houseLootRoll < 0.5) itemRarity = "Common";
                } else if (player.level < 15) {
                    if (houseLootRoll < 0.05) itemRarity = "Legendary";
                    else if (houseLootRoll < 0.15) itemRarity = "Epic";
                    else if (houseLootRoll < 0.45) itemRarity = "Rare";
                    else if (houseLootRoll < 0.7) itemRarity = "Uncommon";
                } else if (player.level < 20) {
                    if (houseLootRoll < 0.1) itemRarity = "Mythic";
                    else if (houseLootRoll < 0.35) itemRarity = "Legendary";
                    else if (houseLootRoll < 0.65) itemRarity = "Epic";
                    else if (houseLootRoll < 0.85) itemRarity = "Rare";
                } else if (player.level < 25) {
                    const rSuper = Math.random();
                    if (rSuper < 0.05) itemRarity = Math.random() < 0.6 ? "Eternal" : "Immortal";
                    else if (houseLootRoll < 0.1) itemRarity = "Divine";
                    else if (houseLootRoll < 0.35) itemRarity = "Mythic";
                    else if (houseLootRoll < 0.65) itemRarity = "Legendary";
                    else if (houseLootRoll < 0.9) itemRarity = "Epic";
                } else {
                    const rSuper = Math.random();
                    if (rSuper < 0.03) itemRarity = "Transcendent";
                    else if (rSuper < 0.1) itemRarity = "Immortal";
                    else if (rSuper < 0.25) itemRarity = "Eternal";
                    else if (houseLootRoll < 0.3) itemRarity = "Divine";
                    else if (houseLootRoll < 0.55) itemRarity = "Mythic";
                    else if (houseLootRoll < 0.95) itemRarity = "Legendary";
                }

                if (itemRarity) {
                    const item = generateItem(itemType, [itemRarity]);
                    let itemBonusText = "";
                    if (item.type === "weapon") {
                        let effectiveAtk = (item.attackBonus || 0) + item.bonus;
                        itemBonusText = `+${effectiveAtk} ATK`;
                        if (item.defenseBonus) itemBonusText += `, +${item.defenseBonus} DEF`;
                    } else {
                        itemBonusText = `+${item.bonus} DEF`;
                    }
                    addLog(
                        `Inside the house, you find a hidden chest containing a <strong class="rarity-${item.rarity}">${item.name}</strong> (${itemBonusText})!`,
                    );
                    tryEquipItem(item);
                    itemFoundInHouse = true;
                }
                if (!itemFoundInHouse) {
                    addLog("The house offered a good rest, but no forgotten treasures this time.");
                }
                updatePlayerStatsUI();
                toggleCombatUI(false);
            }

            function findBlacksmith() {
                addLog(
                    "You find a makeshift forge! A friendly blacksmith offers to temper your gear.",
                );
                const upgradeChoice = Math.random();
                const isRareUpgrade = Math.random() < GAME_CONSTANTS.BLACKSMITH_RARE_UPGRADE_CHANCE;

                let upgradeAmount;
                if (isRareUpgrade) {
                    upgradeAmount =
                        Math.random() < GAME_CONSTANTS.BLACKSMITH_UPGRADE_COMMON_ROLL_THRESHOLD
                            ? GAME_CONSTANTS.BLACKSMITH_UPGRADE_VALUES.RARE[0]
                            : GAME_CONSTANTS.BLACKSMITH_UPGRADE_VALUES.RARE[1];
                } else {
                    upgradeAmount =
                        Math.random() < GAME_CONSTANTS.BLACKSMITH_UPGRADE_RARE_ROLL_THRESHOLD
                            ? GAME_CONSTANTS.BLACKSMITH_UPGRADE_VALUES.COMMON[0]
                            : GAME_CONSTANTS.BLACKSMITH_UPGRADE_VALUES.COMMON[1];
                }

                if (upgradeChoice < 0.33) {
                    // Weapon
                    let enhancedStat = "main bonus";
                    if (
                        player.weapon.name ===
                            GAME_CONSTANTS.INITIAL_PLAYER_STATS.DEFAULT_WEAPON.name &&
                        player.weapon.bonus === 0 &&
                        player.weapon.attackBonus === 0 &&
                        player.weapon.defenseBonus === 0
                    ) {
                        player.weapon.bonus += upgradeAmount;
                    } else if (player.weapon.attackBonus > 0 && player.weapon.defenseBonus > 0) {
                        if (Math.random() < 0.5) {
                            player.weapon.attackBonus += upgradeAmount;
                            enhancedStat = "attack";
                        } else {
                            player.weapon.defenseBonus += upgradeAmount;
                            enhancedStat = "defense";
                        }
                    } else if (player.weapon.attackBonus > 0 && player.weapon.bonus === 0) {
                        player.weapon.attackBonus += upgradeAmount;
                        enhancedStat = "attack";
                    } else {
                        player.weapon.bonus += upgradeAmount;
                    }
                    addLog(
                        `The blacksmith hammers away at your <span class="rarity-${player.weapon.rarity}">${player.weapon.name}</span>. Its ${enhancedStat} feels more potent! (<strong>Enhanced by ${upgradeAmount}</strong>)`,
                    );
                } else if (upgradeChoice < 0.66) {
                    // Armor
                    player.armor.bonus += upgradeAmount;
                    addLog(
                        `The blacksmith reinforces your <span class="rarity-${player.armor.rarity}">${player.armor.name}</span>. It feels sturdier! (<strong>+${upgradeAmount} DEF</strong>)`,
                    );
                } else {
                    // Accessory
                    if (
                        !player.accessory ||
                        player.accessory.name === "None" ||
                        Object.keys(player.accessory.bonuses).length === 0
                    ) {
                        addLog(
                            'The blacksmith looks at your accessory slot and shrugs. "Nothing for me to work on there, friend."',
                        );
                    } else {
                        const bonusKeys = Object.keys(player.accessory.bonuses);
                        if (bonusKeys.length > 0) {
                            const chosenBonusKey =
                                bonusKeys[Math.floor(Math.random() * bonusKeys.length)];
                            let currentBonusValue = player.accessory.bonuses[chosenBonusKey];
                            let actualUpgradeValue;
                            const percentageBonusKeys = [
                                "goldFind",
                                "xpGain",
                                "critChance",
                                "critDamage",
                                "merchantDiscount",
                                "potionEffectiveness",
                                "potionDropChance",
                            ];

                            if (percentageBonusKeys.includes(chosenBonusKey)) {
                                actualUpgradeValue = upgradeAmount * 0.01; // Scale percentage upgrades differently
                                player.accessory.bonuses[chosenBonusKey] = parseFloat(
                                    (currentBonusValue + actualUpgradeValue).toFixed(4),
                                );
                            } else {
                                actualUpgradeValue = upgradeAmount;
                                player.accessory.bonuses[chosenBonusKey] += actualUpgradeValue;
                            }
                            updateAccessoryDescription(player.accessory);

                            let bonusNameForLog = chosenBonusKey
                                .replace(/([A-Z0-9])/g, " $1")
                                .toLowerCase()
                                .trim();
                            bonusNameForLog =
                                bonusNameForLog.charAt(0).toUpperCase() + bonusNameForLog.slice(1);
                            let upgradeDisplayValue = percentageBonusKeys.includes(chosenBonusKey)
                                ? `${(actualUpgradeValue * 100).toFixed(1)}%`
                                : `${actualUpgradeValue}`;
                            addLog(
                                `The blacksmith carefully works on your <span class="rarity-${player.accessory.rarity}">${player.accessory.name}</span>. Its ${bonusNameForLog} has been enhanced by <strong>${upgradeDisplayValue}</strong>!`,
                            );
                        } else {
                            addLog(
                                `The blacksmith inspects your <span class="rarity-${player.accessory.rarity}">${player.accessory.name}</span> but finds no specific property to enhance further.`,
                            );
                        }
                    }
                }
                updatePlayerStatsUI();
                toggleCombatUI(false);
            }

            function findPotionCrate() {
                addLog("You stumble upon an abandoned crate!");
                const potionsFound =
                    GAME_CONSTANTS.POTION_CRATE_MIN_FOUND +
                    Math.floor(
                        Math.random() *
                            (GAME_CONSTANTS.POTION_CRATE_MAX_FOUND_EXCLUSIVE -
                                GAME_CONSTANTS.POTION_CRATE_MIN_FOUND),
                    );
                const potionsCanTake = player.maxPotions - player.potions;
                const potionsTaken = Math.min(potionsFound, potionsCanTake);
                if (potionsTaken > 0) {
                    player.potions += potionsTaken;
                    addLog(
                        `You find <strong>${potionsTaken} Healing Potion${potionsTaken > 1 ? "s" : ""}</strong> inside!`,
                    );
                } else {
                    addLog("The crate is full of potions, but you can't carry any more.");
                }
                updatePlayerStatsUI();
                toggleCombatUI(false);
            }

            function encounterLostCollector() {
                const collectorTemplate = enemies.find(e => e.name === "Lost Collector");
                currentEnemy = {
                    ...collectorTemplate,
                    currentHp: Math.floor(collectorTemplate.baseHp + player.level * 12), // Specific scaling for collector
                    attack: Math.floor(collectorTemplate.baseAttack + player.level * 0.5),
                    defense: Math.floor(collectorTemplate.baseDefense + player.level * 2),
                    isElite: false,
                };
                addLog(`A shimmering figure darts out! It's a <strong>Lost Collector</strong>!`);
                updateEnemyStatsUI();
                toggleCombatUI(true);
            }

            function showPurchaseConfirmation(offer) {
                pendingPurchaseAction = offer.action;
                const tempDiv = document.createElement("div");
                tempDiv.innerHTML = offer.description; // To strip HTML for text content if needed, though here description is rich
                confirmationMessageEl.innerHTML = `Purchase ${offer.description} for ${offer.cost.toLocaleString()} Gold?`; // Using innerHTML as description can be rich
                purchaseConfirmationModalEl.style.display = "flex";
            }

            function hidePurchaseConfirmation() {
                purchaseConfirmationModalEl.style.display = "none";
                pendingPurchaseAction = null;
            }

            confirmPurchaseButtonEl.addEventListener("click", () => {
                if (pendingPurchaseAction) {
                    pendingPurchaseAction();
                    updatePlayerStatsUI();
                    updateMerchantUI();
                }
                hidePurchaseConfirmation();
            });

            cancelPurchaseButtonEl.addEventListener("click", () => {
                hidePurchaseConfirmation();
                addLog("Purchase cancelled.");
            });

            function calculateMerchantItemCost(item) {
                if (item.type === "accessory") {
                    let effectiveCost = item.cost;
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.merchantDiscount
                    ) {
                        effectiveCost = Math.floor(
                            effectiveCost * (1 - player.accessory.bonuses.merchantDiscount),
                        );
                    }
                    return Math.max(1, effectiveCost);
                }

                let baseCostUnit;
                if (item.type === "potion") {
                    baseCostUnit =
                        (item.cost ||
                            GAME_CONSTANTS.MERCHANT_POTION_COST.BASE +
                                player.level * GAME_CONSTANTS.MERCHANT_POTION_COST.PER_LEVEL +
                                player.maxHp * GAME_CONSTANTS.MERCHANT_POTION_COST.PER_MAX_HP) / 8; // Arbitrary division based on original structure
                } else if (item.type === "xp_potion") {
                    baseCostUnit =
                        (item.cost ||
                            player.xpToNextLevel *
                                (GAME_CONSTANTS.MERCHANT_XP_POTION.BASE_COST_FACTOR +
                                    player.level *
                                        GAME_CONSTANTS.MERCHANT_XP_POTION.LEVEL_COST_FACTOR)) / 20; // Arbitrary division
                } else {
                    baseCostUnit =
                        (item.bonus || 0) + (item.attackBonus || 0) + (item.defenseBonus || 0);
                }

                if (baseCostUnit <= 0 && (item.type === "weapon" || item.type === "armor"))
                    baseCostUnit = 1;

                const rarityCostFactors = {
                    Common: 8,
                    Uncommon: 15,
                    Rare: 30,
                    Epic: 60,
                    Legendary: 150,
                    Mythic: 300,
                    Divine: 500,
                    Eternal: 750,
                    Immortal: 1500,
                    Transcendent: 3500,
                };
                let cost = baseCostUnit * (rarityCostFactors[item.rarity] || 8);
                if (item.type !== "potion" && item.type !== "xp_potion") {
                    cost = cost * (1 + player.level * 0.008); // General level scaling for gear
                }
                if (
                    player.accessory &&
                    player.accessory.bonuses &&
                    player.accessory.bonuses.merchantDiscount
                ) {
                    cost = Math.floor(cost * (1 - player.accessory.bonuses.merchantDiscount));
                }
                return Math.max(
                    item.type === "potion" || item.type === "xp_potion" ? 1 : 10,
                    Math.floor(cost),
                );
            }

            function generateMerchantOffers() {
                currentMerchantOffers = [];
                const offerTypesPool = ["potion", "gear", "xp_potion", "accessory"];
                let availableOfferTypes = [...offerTypesPool]; // 'let' as it's modified

                for (let i = 0; i < 2; i++) {
                    if (availableOfferTypes.length === 0) {
                        currentMerchantOffers[i] = null;
                        continue;
                    }

                    let offerType; // 'let'
                    let accessoryOfferAttempted = currentMerchantOffers.some(
                        o => o && o.type === "accessory",
                    );

                    if (
                        availableOfferTypes.includes("accessory") &&
                        !accessoryOfferAttempted &&
                        (i === 0 || Math.random() < 0.5)
                    ) {
                        offerType = "accessory";
                    } else {
                        const tempPool = availableOfferTypes.filter(
                            t => !(t === "accessory" && accessoryOfferAttempted),
                        );
                        if (tempPool.length > 0) {
                            offerType = tempPool[Math.floor(Math.random() * tempPool.length)];
                        } else if (
                            availableOfferTypes.includes("accessory") &&
                            !accessoryOfferAttempted
                        ) {
                            offerType = "accessory";
                        } else {
                            currentMerchantOffers[i] = null;
                            continue;
                        }
                    }
                    const typeIndex = availableOfferTypes.indexOf(offerType);
                    if (typeIndex > -1) {
                        availableOfferTypes.splice(typeIndex, 1);
                    }

                    let offer = {
                        type: offerType,
                        description: "",
                        cost: 0,
                        id: i,
                        purchased: false,
                    }; // 'let' as properties are set

                    if (offerType === "potion") {
                        offer.item = {
                            type: "potion",
                            cost: Math.floor(
                                GAME_CONSTANTS.MERCHANT_POTION_COST.BASE +
                                    player.level * GAME_CONSTANTS.MERCHANT_POTION_COST.PER_LEVEL +
                                    player.maxHp * GAME_CONSTANTS.MERCHANT_POTION_COST.PER_MAX_HP,
                            ),
                        };
                        offer.cost = calculateMerchantItemCost(offer.item);
                        offer.description = `Health Potion`;
                        offer.purchaseMessage = `You bought a Health Potion for ${offer.cost.toLocaleString()} Gold.`;
                        offer.action = () => {
                            if (player.potions < player.maxPotions) {
                                player.gold -= offer.cost;
                                player.potions++;
                                addLog(offer.purchaseMessage);
                                offer.purchased = true;
                            } else {
                                addLog("You can't carry any more potions!");
                            }
                        };
                    } else if (offerType === "gear") {
                        let gearRarity; // 'let'
                        const r = Math.random();
                        // Rarity determination logic (can be further constant-ized if desired for thresholds)
                        if (player.level <= 2) {
                            gearRarity = r < 0.8 ? "Common" : "Uncommon";
                        } else if (player.level <= 4) {
                            gearRarity = r < 0.5 ? "Common" : r < 0.9 ? "Uncommon" : "Rare";
                        }
                        // ... (rest of rarity logic)
                        else if (player.level <= 7) {
                            gearRarity = r < 0.5 ? "Uncommon" : r < 0.9 ? "Rare" : "Epic";
                        } else if (player.level <= 11) {
                            gearRarity = r < 0.5 ? "Rare" : r < 0.9 ? "Epic" : "Legendary";
                        } else if (player.level <= 14) {
                            gearRarity = r < 0.5 ? "Epic" : r < 0.9 ? "Legendary" : "Mythic";
                        } else if (player.level <= 17) {
                            gearRarity = r < 0.45 ? "Legendary" : r < 0.85 ? "Mythic" : "Divine";
                        } else if (player.level <= 20) {
                            gearRarity =
                                r < 0.4
                                    ? "Mythic"
                                    : r < 0.8
                                      ? "Divine"
                                      : r < 0.95
                                        ? "Eternal"
                                        : "Immortal";
                        } else if (player.level <= 24) {
                            if (player.level >= 23 && r < 0.1) gearRarity = "Transcendent";
                            else if (r < 0.2) gearRarity = "Immortal";
                            else if (r < 0.55) gearRarity = "Eternal";
                            else gearRarity = "Divine";
                        } else {
                            if (r < 0.3) gearRarity = "Transcendent";
                            else if (r < 0.7) gearRarity = "Immortal";
                            else gearRarity = "Eternal";
                        }

                        const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                        offer.item = generateItem(itemType, [gearRarity]);
                        offer.cost = calculateMerchantItemCost(offer.item);
                        let itemBonusText = `+${offer.item.bonus + (offer.item.attackBonus || 0)} ${offer.item.type === "weapon" ? "ATK" : "DEF"}`;
                        if (offer.item.type === "weapon" && offer.item.defenseBonus) {
                            itemBonusText += `, +${offer.item.defenseBonus} DEF`;
                        }
                        offer.description = `<span class="rarity-${offer.item.rarity}">${offer.item.name}</span> (${itemBonusText})`;
                        offer.purchaseMessage = `You bought <span class="rarity-${offer.item.rarity}">${offer.item.name}</span> for ${offer.cost.toLocaleString()} Gold.`;
                        offer.action = () => {
                            player.gold -= offer.cost;
                            addLog(offer.purchaseMessage);
                            tryEquipItem(offer.item);
                            offer.purchased = true;
                        };
                    } else if (offerType === "xp_potion") {
                        offer.item = {
                            type: "xp_potion",
                            cost: Math.floor(
                                player.xpToNextLevel *
                                    (GAME_CONSTANTS.MERCHANT_XP_POTION.BASE_COST_FACTOR +
                                        player.level *
                                            GAME_CONSTANTS.MERCHANT_XP_POTION.LEVEL_COST_FACTOR),
                            ),
                        };
                        offer.cost = calculateMerchantItemCost(offer.item);
                        offer.xpAmount = Math.floor(
                            player.xpToNextLevel *
                                (Math.random() *
                                    GAME_CONSTANTS.MERCHANT_XP_POTION.XP_RANDOM_ADDITIONAL_PERCENT +
                                    GAME_CONSTANTS.MERCHANT_XP_POTION.XP_MIN_PERCENT_OF_NEXT_LEVEL),
                        );
                        offer.description = `Flask of Wisdom (+${offer.xpAmount.toLocaleString()} XP)`;
                        offer.purchaseMessage = `You drank the Flask of Wisdom and gained ${offer.xpAmount.toLocaleString()} XP!`;
                        offer.action = () => {
                            player.gold -= offer.cost;
                            player.xp += offer.xpAmount;
                            addLog(offer.purchaseMessage);
                            checkLevelUp();
                            offer.purchased = true;
                        };
                    } else if (offerType === "accessory") {
                        let availableAcc = accessories.filter(acc => {
                            // 'let'
                            if (player.level < 5) return ["Common"].includes(acc.rarity);
                            if (player.level < 10)
                                return ["Common", "Uncommon"].includes(acc.rarity);
                            if (player.level < 18) return ["Uncommon", "Rare"].includes(acc.rarity);
                            if (player.level < 25) return ["Rare", "Epic"].includes(acc.rarity);
                            return ["Epic"].includes(acc.rarity); // Default for higher levels
                        });
                        if (availableAcc.length === 0)
                            availableAcc = accessories.filter(acc => acc.rarity === "Common"); // Fallback
                        if (availableAcc.length === 0) {
                            currentMerchantOffers[i] = null;
                            continue;
                        }

                        const selectedAccessoryTemplate =
                            availableAcc[Math.floor(Math.random() * availableAcc.length)];
                        offer.item = JSON.parse(JSON.stringify(selectedAccessoryTemplate)); // Deep copy
                        offer.cost = calculateMerchantItemCost(offer.item);
                        offer.description = `<span class="rarity-${offer.item.rarity}">${offer.item.name}</span> (${offer.item.description})`;
                        offer.purchaseMessage = `You bought the <span class="rarity-${offer.item.rarity}">${offer.item.name}</span> for ${offer.cost.toLocaleString()} Gold.`;
                        offer.action = () => {
                            player.gold -= offer.cost;
                            // Adjust HP if old accessory had flat HP
                            if (
                                player.accessory &&
                                player.accessory.bonuses &&
                                player.accessory.bonuses.flatHp
                            ) {
                                player.maxHp = Math.max(
                                    1,
                                    player.maxHp - player.accessory.bonuses.flatHp,
                                );
                                player.currentHp = Math.min(player.currentHp, player.maxHp);
                                if (player.currentHp <= 0) player.currentHp = 1;
                            }
                            player.accessory = JSON.parse(JSON.stringify(offer.item)); // Equip new one
                            // Adjust HP if new accessory has flat HP
                            if (player.accessory.bonuses && player.accessory.bonuses.flatHp) {
                                player.maxHp += player.accessory.bonuses.flatHp;
                                // player.currentHp += player.accessory.bonuses.flatHp; // Optionally heal the amount added
                                player.currentHp = Math.min(player.currentHp, player.maxHp); // Ensure not over max
                            }
                            addLog(offer.purchaseMessage);
                            addLog(
                                `Equipped Accessory: <span class="rarity-${player.accessory.rarity}">${player.accessory.name}</span>! (${player.accessory.description})`,
                            );
                            offer.purchased = true;
                        };
                    }
                    currentMerchantOffers[i] = offer.action ? offer : null;
                }
                updateMerchantUI();
            }

            function updateMerchantUI() {
                if (!inMerchantEncounter) return;
                for (let i = 0; i < 2; i++) {
                    const offer = currentMerchantOffers[i];
                    const offerEl = i === 0 ? merchantOffer1El : merchantOffer2El;
                    const buttonEl = i === 0 ? buyOffer1Button : buyOffer2Button;

                    if (offer && offer.type) {
                        offerEl.innerHTML = offer.description; // innerHTML for rich text
                        buttonEl.innerHTML = `Buy (Cost: ${offer.cost.toLocaleString()} G)`; // innerHTML is fine for buttons
                        buttonEl.disabled = offer.purchased || player.gold < offer.cost;
                        if (offer.type === "potion" && player.potions >= player.maxPotions) {
                            buttonEl.disabled = true;
                            if (!offer.purchased)
                                offerEl.innerHTML =
                                    offer.description +
                                    " <span style='color:orange;'>(Max Potions!)</span>";
                        }
                        offerEl.style.display = "block";
                        buttonEl.style.display = "block";
                    } else {
                        offerEl.innerHTML = "--- Nothing on offer ---";
                        buttonEl.innerHTML = "---";
                        buttonEl.disabled = true;
                        if (
                            i === 0 &&
                            (!currentMerchantOffers[1] || !currentMerchantOffers[1].type)
                        ) {
                            // If offer 1 is null and offer 2 is also null/no type
                            merchantOffer2El.style.display = "none";
                            buyOffer2Button.style.display = "none";
                        } else if (i === 1) {
                            // If offer 2 specifically is null
                            offerEl.style.display = "none";
                            buttonEl.style.display = "none";
                        }
                    }
                }
                if (currentMerchantOffers.filter(o => o && o.type).length === 0) {
                    // If both offers are effectively null
                    merchantOffer1El.innerHTML = "The merchant seems to be out of stock.";
                    buyOffer1Button.style.display = "none";
                    merchantOffer2El.style.display = "none";
                    buyOffer2Button.style.display = "none";
                }
            }

            function encounterMerchant() {
                addLog("You encounter a peculiar Wandering Merchant!");
                toggleMerchantUI(true);
                generateMerchantOffers();
            }

            function spawnEnemy() {
                let enemyTemplate; // 'let'
                let enemyPool = []; // 'let'
                let playerLevelAdvantage = 0; // 'let'
                let isElite = false; // 'let'
                const G_CONST = GAME_CONSTANTS; // Shorter alias

                const firstEncounterOverride = firstEncounter; // Store current state
                if (firstEncounter) {
                    firstEncounter = false;
                    enemyTemplate = enemies.find(e => e.name === "Goblin Grunt");
                } else {
                    // Player level based enemy pool selection (can be made more data-driven)
                    if (player.level <= 2) {
                        enemyPool = enemies.filter(
                            e =>
                                ["Slime", "Bat", "Goblin Grunt"].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                    } else if (player.level <= 4) {
                        enemyPool = enemies.filter(
                            e =>
                                ["Skeleton", "Goblin Grunt", "Cave Spider", "Slime"].includes(
                                    e.name,
                                ) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                    }
                    // ... (rest of pooling logic)
                    else if (player.level <= 7) {
                        enemyPool = enemies.filter(
                            e =>
                                ["Orc Scout", "Dire Wolf", "Cave Spider", "Skeleton"].includes(
                                    e.name,
                                ) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                    } else if (player.level <= 10) {
                        enemyPool = enemies.filter(
                            e =>
                                [
                                    "Stone Golem",
                                    "Ogre Brute",
                                    "Deep Goblin Shaman",
                                    "Orc Scout",
                                ].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                    } else if (player.level <= 13) {
                        enemyPool = enemies.filter(
                            e =>
                                [
                                    "Minotaur Charger",
                                    "Wraith",
                                    "Deep Goblin Shaman",
                                    "Ogre Brute",
                                ].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                    } else if (player.level <= 16) {
                        enemyPool = enemies.filter(
                            e =>
                                ["Dread Knight", "Nether Sorcerer", "Wraith"].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                        if (Math.random() < 0.04) {
                            const bP = enemies.filter(e =>
                                ["Ancient Wyrm", "Dungeon Guardian"].includes(e.name),
                            );
                            if (bP.length > 0)
                                enemyPool.push(bP[Math.floor(Math.random() * bP.length)]);
                        }
                    } else if (player.level <= 19) {
                        enemyPool = enemies.filter(
                            e =>
                                [
                                    "Abyssal Behemoth",
                                    "Aspect of Shadow",
                                    "Infernal Juggernaut",
                                    "Archlich Channeler",
                                    "Void Reaver",
                                ].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                        if (Math.random() < 0.05) {
                            const bP = enemies.filter(e =>
                                ["Ancient Wyrm", "Dungeon Guardian"].includes(e.name),
                            );
                            if (bP.length > 0)
                                enemyPool.push(bP[Math.floor(Math.random() * bP.length)]);
                        }
                    } else if (player.level <= 23) {
                        enemyPool = enemies.filter(
                            e =>
                                [
                                    "Celestial Paladin",
                                    "Void Ascendant",
                                    "Chronomancer Adept",
                                    "Corrupted Treant",
                                    "Infernal Juggernaut",
                                    "Archlich Channeler",
                                ].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                        if (Math.random() < 0.06 && !firstEncounterOverride) {
                            const fE = enemies.find(e => e.name === "Reality Sculptor");
                            if (fE) enemyPool.push(fE);
                        }
                    } else if (player.level <= 27) {
                        enemyPool = enemies.filter(
                            e =>
                                [
                                    "Reality Sculptor",
                                    "Celestial Paladin",
                                    "Void Ascendant",
                                    "Chronomancer Adept",
                                    "Corrupted Treant",
                                ].includes(e.name) &&
                                !e.isSpecial &&
                                !e.isFinalBoss,
                        );
                        if (Math.random() < 0.12 && !firstEncounterOverride) {
                            const nT = enemies.find(e => e.name === "The Nether Tyrant");
                            if (nT) enemyPool.push(nT);
                        }
                    } else {
                        enemyPool = enemies.filter(
                            e =>
                                [
                                    "The Nether Tyrant",
                                    "Reality Sculptor",
                                    "Celestial Paladin",
                                    "Void Ascendant",
                                ].includes(e.name) && !e.isSpecial,
                        );
                        if (Math.random() < 0.5 && !firstEncounterOverride) {
                            enemyPool = [
                                enemies.find(e => e.name === "The Nether Tyrant") || enemyPool[0],
                            ];
                        }
                    }

                    if (enemyPool.length === 0) {
                        enemyPool = [
                            enemies.find(
                                e => e.name === "Goblin Grunt" && !e.isSpecial && !e.isFinalBoss,
                            ) || enemies.find(e => !e.isSpecial && !e.isFinalBoss),
                        ];
                    }
                    if (enemyPool.length === 0) enemyPool = [enemies[0]]; // Absolute fallback
                    enemyTemplate = enemyPool[Math.floor(Math.random() * enemyPool.length)];
                }

                const enemyTemplateForScaling = enemies.find(e => e.name === enemyTemplate.name); // Ensure we use the base template for scaling
                const originalEnemyName = enemyTemplateForScaling.name;

                if (
                    player.level >= G_CONST.ELITE_MODIFIERS.SPAWN_MIN_PLAYER_LEVEL &&
                    !enemyTemplateForScaling.isSpecial &&
                    !enemyTemplateForScaling.isFinalBoss &&
                    Math.random() < G_CONST.ELITE_MODIFIERS.SPAWN_CHANCE
                ) {
                    isElite = true;
                }

                let baseHp = enemyTemplateForScaling.baseHp,
                    baseAttack = enemyTemplateForScaling.baseAttack,
                    baseDefense = enemyTemplateForScaling.baseDefense;
                let xpYield = enemyTemplateForScaling.xpYield;
                let goldDropMin = enemyTemplateForScaling.goldDropRange
                    ? enemyTemplateForScaling.goldDropRange[0]
                    : 0;
                let goldDropMax = enemyTemplateForScaling.goldDropRange
                    ? enemyTemplateForScaling.goldDropRange[1]
                    : 0;
                let currentLootTable = enemyTemplateForScaling.lootTable
                    ? JSON.parse(JSON.stringify(enemyTemplateForScaling.lootTable))
                    : []; // Deep copy

                if (isElite) {
                    baseHp = Math.floor(baseHp * G_CONST.ELITE_MODIFIERS.HP_MULTIPLIER);
                    baseAttack = Math.floor(baseAttack * G_CONST.ELITE_MODIFIERS.ATK_MULTIPLIER);
                    baseDefense = Math.floor(baseDefense * G_CONST.ELITE_MODIFIERS.DEF_MULTIPLIER);
                    xpYield = Math.floor(xpYield * G_CONST.ELITE_MODIFIERS.XP_MULTIPLIER);
                    goldDropMin = Math.floor(goldDropMin * G_CONST.ELITE_MODIFIERS.GOLD_MULTIPLIER);
                    goldDropMax = Math.floor(goldDropMax * G_CONST.ELITE_MODIFIERS.GOLD_MULTIPLIER);
                    currentLootTable = currentLootTable.map(loot => ({
                        ...loot,
                        chance: Math.min(
                            1,
                            loot.chance * G_CONST.ELITE_MODIFIERS.LOOT_CHANCE_MULTIPLIER,
                        ),
                    }));
                }

                const enemyIndex = enemies.findIndex(e => e.name === originalEnemyName);
                const enemyLevelTier = Math.max(
                    1,
                    Math.floor(enemyIndex / G_CONST.ENEMY_SCALING.LEVEL_TIER_DIVISOR) + 1,
                );
                playerLevelAdvantage = Math.max(0, player.level - enemyLevelTier);

                currentEnemy = {
                    ...enemyTemplateForScaling, // Spread base template first
                    name: isElite ? "Elite " + originalEnemyName : originalEnemyName,
                    isElite: isElite,
                    baseHp: baseHp, // Overwrite with potentially elite-modified base
                    baseAttack: baseAttack,
                    baseDefense: baseDefense,
                    currentHp: Math.floor(
                        baseHp +
                            playerLevelAdvantage *
                                (baseHp * G_CONST.ENEMY_SCALING.HP_PER_LEVEL_ADVANTAGE_FACTOR) +
                            player.level * G_CONST.ENEMY_SCALING.HP_FLAT_PER_PLAYER_LEVEL,
                    ),
                    attack: Math.floor(
                        baseAttack +
                            playerLevelAdvantage *
                                (baseAttack *
                                    G_CONST.ENEMY_SCALING.ATK_PER_LEVEL_ADVANTAGE_FACTOR) +
                            Math.floor(
                                player.level * G_CONST.ENEMY_SCALING.ATK_FLAT_PER_PLAYER_LEVEL,
                            ),
                    ),
                    defense: Math.floor(
                        baseDefense +
                            playerLevelAdvantage *
                                (baseDefense *
                                    G_CONST.ENEMY_SCALING.DEF_PER_LEVEL_ADVANTAGE_FACTOR) +
                            Math.floor(
                                player.level * G_CONST.ENEMY_SCALING.DEF_FLAT_PER_PLAYER_LEVEL,
                            ),
                    ),
                    xpYield: xpYield, // Use elite-modified if applicable
                    goldDropRange: [goldDropMin, goldDropMax], // Use elite-modified if applicable
                    lootTable: currentLootTable, // Use elite-modified if applicable
                    // Preserve specific flags from original template
                    ignoresDefense: enemyTemplateForScaling.ignoresDefense || false,
                    timeWarpHealChance: enemyTemplateForScaling.timeWarpHealChance || 0,
                    timeWarpAttackChance: enemyTemplateForScaling.timeWarpAttackChance || 0,
                    lifeLeechMultiplier: enemyTemplateForScaling.lifeLeechMultiplier || 0,
                    isSpecial: enemyTemplateForScaling.isSpecial || false,
                    isFinalBoss: enemyTemplateForScaling.isFinalBoss || false,
                };
                // Ensure scaled stats are not less than base (especially after elite modification of base)
                currentEnemy.currentHp = Math.max(baseHp, currentEnemy.currentHp);
                currentEnemy.attack = Math.max(baseAttack, currentEnemy.attack);
                currentEnemy.defense = Math.max(baseDefense, currentEnemy.defense);

                addLog(
                    `A wild ${currentEnemy.isElite ? `<span class="elite-enemy">${currentEnemy.name}</span>` : `<strong>${currentEnemy.name}</strong>`} (Lvl ~${player.level}) appears!${currentEnemy.isElite ? " It radiates a menacing aura!" : ""}`,
                );
                updateEnemyStatsUI();
                toggleCombatUI(true);
            }

            exploreButton.addEventListener("click", () => {
                addLog("You venture deeper into the dungeon...");
                const rand = Math.random();
                const T = GAME_CONSTANTS.EXPLORE_EVENT_THRESHOLDS;

                if (firstEncounter) {
                    // firstEncounter is a global 'let'
                    spawnEnemy();
                    return;
                }

                if (rand < T.LOST_COLLECTOR) {
                    encounterLostCollector();
                } else if (rand < T.POTION_CRATE) {
                    findPotionCrate();
                } else if (rand < T.MERCHANT) {
                    encounterMerchant();
                } else if (rand < T.STRAY_POTION) {
                    if (player.potions < player.maxPotions) {
                        player.potions++;
                        addLog("You found a stray Healing Potion!");
                        updatePlayerStatsUI();
                    } else {
                        addLog("You spot a potion, but can't carry more.");
                    }
                    toggleCombatUI(false); // No combat for stray potion
                } else if (rand < T.BLACKSMITH) {
                    findBlacksmith();
                } else if (rand < T.REST_HOUSE) {
                    findRestHouse();
                } else {
                    // Default: Spawn Enemy
                    spawnEnemy();
                }
            });

            attackButton.addEventListener("click", () => {
                if (!currentEnemy || !inCombat) return;
                player.isDefending = false;
                const G_CONST_PLAYER = GAME_CONSTANTS.PLAYER_BASE_CRIT_CHANCE; // Alias for readability

                let playerEffectiveAttack =
                    player.baseAttack +
                    player.weapon.bonus +
                    (player.weapon.attackBonus || 0) +
                    ((player.accessory && player.accessory.bonuses.flatAttack) || 0);
                let playerDamage = Math.max(1, playerEffectiveAttack - currentEnemy.defense);

                let critChance =
                    G_CONST_PLAYER +
                    player.level * GAME_CONSTANTS.PLAYER_CRIT_CHANCE_LEVEL_MULTIPLIER +
                    ((player.accessory && player.accessory.bonuses.critChance) || 0);
                const enemyDisplayName = currentEnemy.isElite
                    ? `<span class="elite-enemy">${currentEnemy.name}</span>`
                    : `<strong>${currentEnemy.name}</strong>`;

                if (Math.random() < critChance) {
                    let critMultiplier =
                        GAME_CONSTANTS.PLAYER_BASE_CRIT_DAMAGE_MULTIPLIER +
                        player.level * GAME_CONSTANTS.PLAYER_CRIT_DAMAGE_LEVEL_MULTIPLIER +
                        ((player.accessory && player.accessory.bonuses.critDamage) || 0);
                    playerDamage = Math.floor(playerDamage * critMultiplier);
                    addLog(
                        `<strong>CRITICAL HIT!</strong> You attack ${enemyDisplayName} for <strong style="color:#ff8c00;">${playerDamage}</strong> damage!`,
                    );
                } else {
                    addLog(
                        `You attack ${enemyDisplayName} for <strong>${playerDamage}</strong> damage.`,
                    );
                }
                currentEnemy.currentHp = Math.max(0, currentEnemy.currentHp - playerDamage);
                updateEnemyStatsUI();
                if (currentEnemy.currentHp <= 0) {
                    handleEnemyDefeat();
                } else {
                    enemyTurn();
                }
            });

            defendButton.addEventListener("click", () => {
                if (!currentEnemy || !inCombat) return;
                player.isDefending = true;
                addLog("You brace for the next attack, effectively doubling your total defense.");
                enemyTurn();
            });

            potionButton.addEventListener("click", () => {
                if (player.potions > 0 && player.currentHp < player.maxHp && inCombat) {
                    player.potions--;
                    let healAmount = Math.floor(
                        player.maxHp *
                            (GAME_CONSTANTS.POTION_HEAL_BASE_PERCENT +
                                player.level * GAME_CONSTANTS.POTION_HEAL_LEVEL_MULTIPLIER),
                    );
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.potionEffectiveness
                    ) {
                        healAmount = Math.floor(
                            healAmount * (1 + player.accessory.bonuses.potionEffectiveness),
                        );
                    }
                    player.currentHp = Math.min(player.maxHp, player.currentHp + healAmount);
                    addLog(`You drink a potion and restore <strong>${healAmount}</strong> HP.`);
                    updatePlayerStatsUI(); // potionButton state might change
                } else if (player.potions <= 0) {
                    addLog("No potions left!");
                } else if (player.currentHp === player.maxHp) {
                    addLog("HP is already full!");
                }
            });

            function enemyTurn() {
                if (!currentEnemy || currentEnemy.currentHp <= 0) return;

                let effectivePlayerDefense =
                    (player.baseDefense +
                        player.armor.bonus +
                        (player.weapon.defenseBonus || 0) +
                        ((player.accessory && player.accessory.bonuses.flatDefense) || 0)) *
                    (player.isDefending ? 2 : 1);
                let enemyDamage;
                const enemyDisplayName = currentEnemy.isElite
                    ? `<span class="elite-enemy">${currentEnemy.name}</span>`
                    : `<strong>${currentEnemy.name}</strong>`;
                let messagePrefix = enemyDisplayName;

                if (currentEnemy.ignoresDefense) {
                    enemyDamage = currentEnemy.attack;
                    messagePrefix += "'s <strong style='color:#BA55D3;'>piercing attack</strong>";
                } else {
                    enemyDamage = Math.max(1, currentEnemy.attack - effectivePlayerDefense);
                }

                const critRoll = Math.random();
                const enemyCritChance =
                    GAME_CONSTANTS.ENEMY_BASE_CRIT_CHANCE +
                    player.level * GAME_CONSTANTS.ENEMY_CRIT_CHANCE_LEVEL_MULTIPLIER; // Enemy crit might scale with player level or enemy tier. Here, using player level as per original implication.
                if (
                    currentEnemy.attack >
                        (currentEnemy.ignoresDefense ? -1 : effectivePlayerDefense) &&
                    critRoll < enemyCritChance
                ) {
                    const critMultiplier =
                        GAME_CONSTANTS.ENEMY_BASE_CRIT_DAMAGE_MULTIPLIER +
                        player.level * GAME_CONSTANTS.ENEMY_CRIT_DAMAGE_LEVEL_MULTIPLIER;
                    enemyDamage = Math.floor(enemyDamage * critMultiplier);
                    addLog(
                        `${messagePrefix} lands a <strong style="color:#ff4500;">critical blow</strong> for <strong>${enemyDamage}</strong> damage!`,
                    );
                } else {
                    if (currentEnemy.ignoresDefense) {
                        addLog(
                            `${messagePrefix} hits you for <strong>${enemyDamage}</strong> damage!`,
                        );
                    } else {
                        addLog(
                            `${messagePrefix} attacks you for <strong>${enemyDamage}</strong> damage.`,
                        );
                    }
                }

                if (player.isDefending && !currentEnemy.ignoresDefense) {
                    addLog("Your defense reduced the damage!");
                }
                player.isDefending = false; // Reset defense stance
                player.currentHp = Math.max(0, player.currentHp - enemyDamage);
                updatePlayerStatsUI();

                if (player.currentHp <= 0) {
                    handlePlayerDefeat();
                    return; // Stop further enemy actions if player is defeated
                }

                // Special enemy abilities after attack
                const actualEnemyNameForAbilities = currentEnemy.isElite
                    ? currentEnemy.name.substring(6)
                    : currentEnemy.name; // Get base name if elite
                const enemyTemplateOriginal = enemies.find(
                    e => e.name === actualEnemyNameForAbilities,
                ); // Find original template for abilities

                if (enemyTemplateOriginal) {
                    // Check if template found
                    if (actualEnemyNameForAbilities === "Chronomancer Adept") {
                        if (Math.random() < (currentEnemy.timeWarpHealChance || 0)) {
                            // Use currentEnemy's potentially scaled chance
                            const healAmount = Math.floor(enemyTemplateOriginal.baseHp * 0.15); // Heal based on original template's base HP
                            currentEnemy.currentHp = Math.min(
                                currentEnemy.baseHp,
                                currentEnemy.currentHp + healAmount,
                            ); // Cap heal at its own base (potentially elite)
                            addLog(
                                `The ${enemyDisplayName} warps time, restoring <strong style="color:lightgreen;">${healAmount}</strong> HP!`,
                            );
                            updateEnemyStatsUI();
                        }
                    }
                    if (actualEnemyNameForAbilities === "Corrupted Treant" && enemyDamage > 0) {
                        const leechAmount = Math.floor(
                            enemyDamage * (currentEnemy.lifeLeechMultiplier || 0),
                        );
                        if (leechAmount > 0) {
                            currentEnemy.currentHp = Math.min(
                                currentEnemy.baseHp,
                                currentEnemy.currentHp + leechAmount,
                            );
                            addLog(
                                `The ${enemyDisplayName} leeches <strong style="color:darkgreen;">${leechAmount}</strong> HP from you!`,
                            );
                            updateEnemyStatsUI();
                        }
                    }
                    // Chronomancer extra attack
                    if (
                        player.currentHp > 0 &&
                        actualEnemyNameForAbilities === "Chronomancer Adept" &&
                        Math.random() < (currentEnemy.timeWarpAttackChance || 0)
                    ) {
                        addLog(`The ${enemyDisplayName} bends time and attacks again!`);
                        let extraEnemyDamage;
                        let extraMessagePrefix = `${enemyDisplayName}'s extra attack`;
                        // Recalculate defense for this extra attack as player is no longer defending
                        let extraEffectivePlayerDefense =
                            player.baseDefense +
                            player.armor.bonus +
                            (player.weapon.defenseBonus || 0) +
                            ((player.accessory && player.accessory.bonuses.flatDefense) || 0);

                        if (currentEnemy.ignoresDefense) {
                            extraEnemyDamage = currentEnemy.attack;
                            extraMessagePrefix +=
                                " <strong style='color:#BA55D3;'>pierces</strong>";
                        } else {
                            extraEnemyDamage = Math.max(
                                1,
                                currentEnemy.attack - extraEffectivePlayerDefense,
                            );
                        }

                        if (
                            currentEnemy.attack >
                                (currentEnemy.ignoresDefense ? -1 : extraEffectivePlayerDefense) &&
                            Math.random() < enemyCritChance
                        ) {
                            // Re-use previous crit chance
                            const critMultiplier =
                                GAME_CONSTANTS.ENEMY_BASE_CRIT_DAMAGE_MULTIPLIER +
                                player.level * GAME_CONSTANTS.ENEMY_CRIT_DAMAGE_LEVEL_MULTIPLIER;
                            extraEnemyDamage = Math.floor(extraEnemyDamage * critMultiplier);
                            addLog(
                                `${extraMessagePrefix} lands a <strong style="color:#ff4500;">critical blow</strong> for <strong>${extraEnemyDamage}</strong> damage!`,
                            );
                        } else {
                            addLog(
                                `${extraMessagePrefix} hits you for <strong>${extraEnemyDamage}</strong> damage.`,
                            );
                        }
                        player.currentHp = Math.max(0, player.currentHp - extraEnemyDamage);
                        updatePlayerStatsUI();
                        if (player.currentHp <= 0) {
                            handlePlayerDefeat();
                        }
                    }
                }
            }

            function handleRegularLootDrop(defeatedEnemyNameForLogDisplay) {
                const enemyDataForLoot = currentEnemy; // Current enemy holds the potentially elite-modified loot table

                if (!enemyDataForLoot || !enemyDataForLoot.lootTable) {
                    return; // No loot table defined
                }

                enemyDataForLoot.lootTable.forEach(lootEntry => {
                    if (Math.random() < lootEntry.chance) {
                        // Use the (potentially elite-boosted) chance from currentEnemy
                        let item; // 'let'
                        let logMessagePrefix = `The ${defeatedEnemyNameForLogDisplay} dropped`;

                        if (lootEntry.isUnique) {
                            item = generateItem(
                                lootEntry.uniqueItemType,
                                [lootEntry.uniqueRarity],
                                lootEntry,
                            );
                            logMessagePrefix += ` something special: `;
                        } else {
                            // Rarities from lootEntry might be an array, ensure generateItem handles this
                            item = generateItem(lootEntry.type, lootEntry.rarities);
                        }

                        let itemBonusText = "";
                        let effectiveAttack = 0;

                        if (item.type === "weapon") {
                            effectiveAttack = (item.attackBonus || 0) + item.bonus;
                            if (item.attackBonus > 0 && item.defenseBonus > 0) {
                                // Hybrid weapon case
                                effectiveAttack = item.attackBonus; // Only count attackBonus as the "main" part for display here
                            }
                            itemBonusText = `+${effectiveAttack} ATK`;
                            if (item.defenseBonus) {
                                itemBonusText += `, +${item.defenseBonus} DEF`;
                            }
                        } else if (item.type === "armor") {
                            itemBonusText = `+${item.bonus} DEF`;
                        }

                        let originalName = item.name; // Store original name before potential forging modification
                        // Check if the original enemy template had this as a forgable item
                        const actualEnemyName = currentEnemy.isElite
                            ? currentEnemy.name.substring(6)
                            : currentEnemy.name;
                        const originalEnemyTemplate = enemies.find(e => e.name === actualEnemyName);
                        const originalLootEntry =
                            originalEnemyTemplate && originalEnemyTemplate.lootTable
                                ? originalEnemyTemplate.lootTable.find(
                                      l =>
                                          l.type === lootEntry.type &&
                                          ((l.isUnique === lootEntry.isUnique &&
                                              l.uniqueName === lootEntry.uniqueName) ||
                                              (!l.isUnique && !lootEntry.isUnique)),
                                  )
                                : null;

                        if (originalLootEntry && originalLootEntry.isForgable) {
                            const forgedBonus = Math.floor(Math.random() * 20) + 1; // Example forge bonus
                            if (item.type === "weapon") {
                                if (item.attackBonus > 0 && item.defenseBonus > 0)
                                    item.attackBonus += forgedBonus; // Add to attack if hybrid
                                else item.bonus += forgedBonus; // Add to main bonus otherwise

                                effectiveAttack = (item.attackBonus || 0) + item.bonus;
                                if (item.attackBonus > 0 && item.defenseBonus > 0) {
                                    effectiveAttack = item.attackBonus;
                                }
                                itemBonusText = `+${effectiveAttack} ATK`;
                                if (item.defenseBonus)
                                    itemBonusText += `, +${item.defenseBonus} DEF`;
                            } else {
                                // Armor
                                item.bonus += forgedBonus;
                                itemBonusText = `+${item.bonus} DEF`;
                            }
                            item.name = `${originalName} (Forged +${forgedBonus})`;
                            logMessagePrefix = `The ${defeatedEnemyNameForLogDisplay} dropped a forged item: `;
                        }
                        addLog(
                            `${logMessagePrefix}<strong class="rarity-${item.rarity}">${item.name}</strong> (${itemBonusText})!`,
                        );
                        tryEquipItem(item);
                    }
                });
            }

            function handleEnemyDefeat() {
                const defeatedEnemyNameForLog = currentEnemy.isElite
                    ? `<span class="elite-enemy">${currentEnemy.name}</span>`
                    : `<strong>${currentEnemy.name}</strong>`;
                const originalXpYield = currentEnemy.xpYield; // This is already elite-modified if applicable
                const enemyDataForLoot = currentEnemy; // Contains potentially elite-modified gold/loot
                const G_CONST = GAME_CONSTANTS; // Alias

                addLog(`You defeated the ${defeatedEnemyNameForLog}!`);

                // Gold Drop
                if (enemyDataForLoot && enemyDataForLoot.goldDropRange) {
                    let goldDropped =
                        enemyDataForLoot.goldDropRange[0] +
                        Math.floor(
                            Math.random() *
                                (enemyDataForLoot.goldDropRange[1] -
                                    enemyDataForLoot.goldDropRange[0] +
                                    1),
                        );
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.goldFind
                    ) {
                        goldDropped = Math.floor(
                            goldDropped * (1 + player.accessory.bonuses.goldFind),
                        );
                    }
                    player.gold += goldDropped;
                    addLog(
                        `The ${defeatedEnemyNameForLog} dropped <strong style="color:#ffd700;">${goldDropped.toLocaleString()} Gold</strong>!`,
                    );
                }

                const actualEnemyName = currentEnemy.isElite
                    ? currentEnemy.name.substring(6)
                    : currentEnemy.name;

                // Special handling for Lost Collector
                if (actualEnemyName === "Lost Collector") {
                    const xpReward = Math.floor(
                        player.xpToNextLevel *
                            (G_CONST.LOST_COLLECTOR_XP_REWARD.BASE_PERCENT_OF_NEXT_LEVEL +
                                player.level * G_CONST.LOST_COLLECTOR_XP_REWARD.PER_LEVEL_PERCENT),
                    );
                    let finalXpReward = xpReward;
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.xpGain
                    ) {
                        finalXpReward = Math.floor(
                            finalXpReward * (1 + player.accessory.bonuses.xpGain),
                        );
                    }
                    player.xp += finalXpReward;
                    addLog(
                        `The Lost Collector dissolves, leaving behind a massive surge of experience! Gained <strong>${finalXpReward.toLocaleString()}</strong> XP.`,
                    );

                    const collectorBonus =
                        G_CONST.LOST_COLLECTOR_GEAR_BONUS_BASE +
                        Math.floor(player.level / G_CONST.LOST_COLLECTOR_GEAR_BONUS_PER_4_LEVELS);
                    if (player.weapon.attackBonus > 0 && player.weapon.defenseBonus > 0)
                        player.weapon.attackBonus += collectorBonus; // Hybrid weapon
                    else player.weapon.bonus += collectorBonus; // Standard weapon
                    player.armor.bonus += collectorBonus;
                    addLog(
                        `A strange energy enhances your gear! Your <span class="rarity-${player.weapon.rarity}">${player.weapon.name}</span> gains +${collectorBonus} to its main attack stat and your <span class="rarity-${player.armor.rarity}">${player.armor.name}</span> gains +${collectorBonus} DEF!`,
                    );
                }
                // Special handling for Final Boss
                else if (currentEnemy.isFinalBoss) {
                    addLog("The Nether Tyrant shatters into oblivion, its dark power dispersed!");
                    let finalXpYield = originalXpYield; // Already contains elite/base XP
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.xpGain
                    ) {
                        finalXpYield = Math.floor(
                            finalXpYield * (1 + player.accessory.bonuses.xpGain),
                        );
                    }
                    player.xp += finalXpYield;
                    addLog(`Gained <strong>${finalXpYield.toLocaleString()}</strong> XP.`);

                    const potionsGained =
                        G_CONST.FINAL_BOSS_LOOT.POTIONS_GAINED_BASE +
                        Math.floor(
                            player.level / G_CONST.FINAL_BOSS_LOOT.POTIONS_PER_5_PLAYER_LEVELS,
                        );
                    const canTake = player.maxPotions - player.potions;
                    const actuallyGained = Math.min(potionsGained, canTake);
                    if (actuallyGained > 0) {
                        player.potions += actuallyGained;
                        addLog(
                            `The Tyrant dropped <strong>${actuallyGained} Healing Potion${actuallyGained > 1 ? "s" : ""}</strong>!`,
                        );
                    }
                    // Guaranteed high-tier items
                    const numHighItems =
                        G_CONST.FINAL_BOSS_LOOT.HIGH_ITEM_COUNT_BASE +
                        (Math.random() < G_CONST.FINAL_BOSS_LOOT.HIGH_ITEM_ADDITIONAL_CHANCE
                            ? 1
                            : 0);
                    for (let i = 0; i < numHighItems; i++) {
                        const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                        const item = generateItem(itemType, ["Mythic", "Divine"]); // Example rarities
                        addLog(
                            `It dropped a pulsating <strong class="rarity-${item.rarity}">${item.name}</strong> (+${(item.bonus || 0) + (item.attackBonus || 0)} ${item.type === "weapon" ? "ATK" : "DEF"})!`,
                        );
                        tryEquipItem(item);
                    }
                    // Chance for even higher tier
                    if (Math.random() < G_CONST.FINAL_BOSS_LOOT.ETERNAL_DROP_CHANCE) {
                        const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                        const item = generateItem(itemType, ["Eternal"]);
                        addLog(
                            `Among the remains, an <strong class="rarity-Eternal">${item.name}</strong> (+${(item.bonus || 0) + (item.attackBonus || 0)} ${item.type === "weapon" ? "ATK" : "DEF"}) gleams!`,
                        );
                        tryEquipItem(item);
                    }
                    if (Math.random() < G_CONST.FINAL_BOSS_LOOT.IMMORTAL_DROP_CHANCE) {
                        const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                        const item = generateItem(itemType, ["Immortal"]);
                        addLog(
                            `A shard of pure power materializes into an <strong class="rarity-Immortal">${item.name}</strong> (+${(item.bonus || 0) + (item.attackBonus || 0)} ${item.type === "weapon" ? "ATK" : "DEF"})!`,
                        );
                        tryEquipItem(item);
                    }
                    if (Math.random() < G_CONST.FINAL_BOSS_LOOT.TRANSCENDENT_DROP_CHANCE) {
                        const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                        const item = generateItem(itemType, ["Transcendent"]);
                        addLog(
                            `An echo of ultimate power forms into a <strong class="rarity-Transcendent">${item.name}</strong> (+${(item.bonus || 0) + (item.attackBonus || 0)} ${item.type === "weapon" ? "ATK" : "DEF"})!`,
                        );
                        tryEquipItem(item);
                    }
                }
                // Regular enemy defeat
                else {
                    let finalXpYield = originalXpYield; // Already contains elite/base XP
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.xpGain
                    ) {
                        finalXpYield = Math.floor(
                            finalXpYield * (1 + player.accessory.bonuses.xpGain),
                        );
                    }
                    player.xp += finalXpYield;
                    addLog(`Gained <strong>${finalXpYield.toLocaleString()}</strong> XP.`);

                    // Potion Drop
                    const baseEnemyTemplateForPotion = enemies.find(
                        e => e.name === actualEnemyName,
                    );
                    let effectivePotionDropChance =
                        (baseEnemyTemplateForPotion &&
                            baseEnemyTemplateForPotion.potionDropChance) ||
                        0;
                    if (currentEnemy.isElite)
                        effectivePotionDropChance *= G_CONST.ELITE_MODIFIERS.LOOT_CHANCE_MULTIPLIER; // Elites have better potion drop
                    if (
                        player.accessory &&
                        player.accessory.bonuses &&
                        player.accessory.bonuses.potionDropChance
                    ) {
                        effectivePotionDropChance += player.accessory.bonuses.potionDropChance;
                    }
                    if (
                        Math.random() < effectivePotionDropChance &&
                        player.potions < player.maxPotions
                    ) {
                        player.potions++;
                        addLog(`The ${defeatedEnemyNameForLog} dropped a Healing Potion!`);
                    }

                    // Boss-specific potion drops (non-final bosses)
                    if (
                        (actualEnemyName === "Ancient Wyrm" ||
                            actualEnemyName === "Dungeon Guardian") &&
                        player.potions < player.maxPotions
                    ) {
                        const bossPotions =
                            Math.floor(Math.random() * 3) + (currentEnemy.isElite ? 3 : 2);
                        const canTakeBossPotions = player.maxPotions - player.potions;
                        const actuallyGainedBossPotions = Math.min(bossPotions, canTakeBossPotions);
                        if (actuallyGainedBossPotions > 0) {
                            player.potions += actuallyGainedBossPotions;
                            addLog(
                                `The mighty ${defeatedEnemyNameForLog} dropped <strong>${actuallyGainedBossPotions} Healing Potion${actuallyGainedBossPotions > 1 ? "s" : ""}</strong>!`,
                            );
                        }
                    }

                    handleRegularLootDrop(defeatedEnemyNameForLog); // Handles item drops based on lootTable

                    // Special high-tier loot for specific non-final bosses
                    const specialLootEnemyNames = [
                        "Dread Knight",
                        "Nether Sorcerer",
                        "Void Reaver",
                        "Abyssal Behemoth",
                        "Aspect of Shadow",
                        "Infernal Juggernaut",
                        "Archlich Channeler",
                        "Ancient Wyrm",
                        "Dungeon Guardian",
                    ];
                    const isNewHighTierEnemy = [
                        "Celestial Paladin",
                        "Void Ascendant",
                        "Reality Sculptor",
                        "Chronomancer Adept",
                        "Corrupted Treant",
                    ].includes(actualEnemyName);

                    if (
                        !isNewHighTierEnemy &&
                        specialLootEnemyNames.includes(actualEnemyName) &&
                        !currentEnemy.isElite
                    ) {
                        // Elite loot is handled by boosted regular table
                        let ultraLootChance = 0;
                        let transcendentLootChance = 0;

                        if (
                            actualEnemyName === "Ancient Wyrm" ||
                            actualEnemyName === "Dungeon Guardian"
                        ) {
                            ultraLootChance = G_CONST.SPECIAL_BOSS_LOOT.WYRM_GUARDIAN.ULTRA_CHANCE;
                            transcendentLootChance =
                                G_CONST.SPECIAL_BOSS_LOOT.WYRM_GUARDIAN.TRANSCENDENT_CHANCE;
                        } else if (specialLootEnemyNames.includes(actualEnemyName)) {
                            // Other listed special enemies
                            ultraLootChance =
                                G_CONST.SPECIAL_BOSS_LOOT.HIGH_TIER_REGULAR.ULTRA_CHANCE;
                            if (
                                [
                                    "Void Reaver",
                                    "Infernal Juggernaut",
                                    "Archlich Channeler",
                                ].includes(actualEnemyName)
                            ) {
                                transcendentLootChance =
                                    G_CONST.SPECIAL_BOSS_LOOT.VOID_ETC_TRANSCENDENT_CHANCE;
                            }
                        }

                        if (transcendentLootChance > 0 && Math.random() < transcendentLootChance) {
                            const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                            const item = generateItem(itemType, ["Transcendent"]);
                            addLog(
                                `Beyond comprehension! A <strong class="rarity-Transcendent">${item.name}</strong> (+${(item.bonus || 0) + (item.attackBonus || 0)} ${item.type === "weapon" ? "ATK" : "DEF"}) manifests from the dissipating foe!`,
                            );
                            tryEquipItem(item);
                        } else if (ultraLootChance > 0 && Math.random() < ultraLootChance) {
                            const itemType = Math.random() < 0.5 ? "weapon" : "armor";
                            const superRarity = Math.random() < 0.5 ? "Eternal" : "Immortal";
                            const item = generateItem(itemType, [superRarity]);
                            addLog(
                                `The fallen foe radiates immense power, dropping an <strong class="rarity-${item.rarity}">${item.name}</strong> (+${(item.bonus || 0) + (item.attackBonus || 0)} ${item.type === "weapon" ? "ATK" : "DEF"})!`,
                            );
                            tryEquipItem(item);
                        }
                    }
                }

                currentEnemy = null;
                updateEnemyStatsUI();
                checkLevelUp();
                toggleCombatUI(false);
            }

            function checkLevelUp() {
                let leveledUp = false; // 'let' as it's a flag
                const G_CONST_LU = GAME_CONSTANTS.LEVEL_UP_XP_MULTIPLIERS;
                const G_CONST_HP = GAME_CONSTANTS.LEVEL_UP_HP_GAIN;
                const G_CONST_ATK = GAME_CONSTANTS.LEVEL_UP_ATTACK_GAIN;
                const G_CONST_DEF = GAME_CONSTANTS.LEVEL_UP_DEFENSE_GAIN;

                while (player.xp >= player.xpToNextLevel) {
                    leveledUp = true;
                    const oldLevelRequirement = player.xpToNextLevel;
                    player.level++;
                    player.xp -= oldLevelRequirement;

                    const levelConfig =
                        G_CONST_LU.find(m => player.level >= m.minLevel) ||
                        G_CONST_LU[G_CONST_LU.length - 1];
                    let newXpToNextLevel = Math.floor(oldLevelRequirement * levelConfig.multiplier);
                    // Prevent XP requirement from stagnating or decreasing at very high levels if multiplier is too low
                    if (newXpToNextLevel <= oldLevelRequirement && player.level > 1) {
                        newXpToNextLevel = Math.floor(oldLevelRequirement * 1.05) + 50;
                    }
                    player.xpToNextLevel = newXpToNextLevel;

                    const hpGain =
                        Math.floor(
                            player.maxHp *
                                (G_CONST_HP.BASE_PERCENT +
                                    player.level * G_CONST_HP.LEVEL_MULTIPLIER),
                        ) +
                        (G_CONST_HP.FLAT_BASE + player.level);

                    let attackGain =
                        Math.floor(
                            player.baseAttack *
                                (G_CONST_ATK.BASE_PERCENT +
                                    player.level * G_CONST_ATK.LEVEL_MULTIPLIER),
                        ) +
                        (player.level % 2 === 0
                            ? G_CONST_ATK.EVEN_LEVEL_BONUS
                            : G_CONST_ATK.ODD_LEVEL_BONUS) +
                        Math.floor(player.level / 4) * G_CONST_ATK.PER_4_LEVELS_BONUS;

                    let defenseGain =
                        Math.floor(
                            player.baseDefense *
                                (G_CONST_DEF.BASE_PERCENT +
                                    player.level * G_CONST_DEF.LEVEL_MULTIPLIER),
                        ) +
                        (player.level % 3 === 0
                            ? G_CONST_DEF.PER_3_LEVELS_BONUS
                            : G_CONST_DEF.OTHER_LEVELS_BONUS) +
                        Math.floor(player.level / 5) * G_CONST_DEF.PER_5_LEVELS_BONUS;

                    player.maxHp += hpGain;
                    player.currentHp = player.maxHp; // Full heal on level up
                    player.baseAttack += attackGain;
                    player.baseDefense += defenseGain;

                    addLog(
                        `<strong style="color: #00dd00;">LEVEL UP! You are now Level ${player.level}!</strong>`,
                    );
                    addLog(
                        `Max HP +${hpGain}, Base ATK +${attackGain}, Base DEF +${defenseGain}. HP restored.`,
                    );
                }
                if (leveledUp) updatePlayerStatsUI();
            }

            function handlePlayerDefeat() {
                addLog(`<strong style="color: #ff0000;">You have been defeated!</strong>`);
                gameOverMessageEl.textContent = `Game Over! You reached Level ${player.level}.`;
                gameOverScreenEl.style.display = "block";
                toggleCombatUI(false); // Ensure combat UI is hidden
                exploreButton.style.display = "none"; // Hide explore button
                enemyAreaEl.style.display = "none"; // Hide enemy area
                merchantAreaEl.style.display = "none"; // Hide merchant area
            }

            function resetGame() {
                const INIT_STATS = GAME_CONSTANTS.INITIAL_PLAYER_STATS;
                player = {
                    level: INIT_STATS.LEVEL,
                    xp: INIT_STATS.XP,
                    xpToNextLevel: INIT_STATS.XP_TO_NEXT_LEVEL,
                    currentHp: INIT_STATS.CURRENT_HP,
                    maxHp: INIT_STATS.MAX_HP,
                    baseAttack: INIT_STATS.BASE_ATTACK,
                    baseDefense: INIT_STATS.BASE_DEFENSE,
                    potions: INIT_STATS.POTIONS,
                    maxPotions: INIT_STATS.MAX_POTIONS, // Defined in constants
                    gold: INIT_STATS.GOLD,
                    isDefending: false,
                    weapon: { ...INIT_STATS.DEFAULT_WEAPON }, // Shallow copy for safety
                    armor: { ...INIT_STATS.DEFAULT_ARMOR }, // Shallow copy
                    accessory: {
                        ...INIT_STATS.DEFAULT_ACCESSORY,
                        bonuses: { ...INIT_STATS.DEFAULT_ACCESSORY.bonuses },
                    }, // Deeper copy for bonuses
                };
                updateAccessoryDescription(player.accessory); // Initialize description for default accessory

                firstEncounter = true;
                inCombat = false;
                inMerchantEncounter = false;
                currentEnemy = null;
                currentMerchantOffers = [];
                pendingPurchaseAction = null;

                logEl.innerHTML = '<p>Welcome to the Dungeon! Click "Explore" to begin.</p>';
                if (helpModalEl) helpModalEl.style.display = "none"; // Ensure help is hidden

                updatePlayerStatsUI();
                updateEnemyStatsUI();
                toggleCombatUI(false);
                toggleMerchantUI(false);
                exploreButton.style.display = "block";
                gameOverScreenEl.style.display = "none";
                hidePurchaseConfirmation(); // Ensure purchase confirmation is hidden
            }

            // Event Listeners
            if (helpButton) {
                helpButton.addEventListener("click", () => {
                    if (helpModalEl) helpModalEl.style.display = "flex";
                });
            }
            if (closeHelpModalButtonEl) {
                closeHelpModalButtonEl.addEventListener("click", () => {
                    if (helpModalEl) helpModalEl.style.display = "none";
                });
            }

            buyOffer1Button.addEventListener("click", () => {
                const offer = currentMerchantOffers[0];
                if (offer && offer.action && !offer.purchased && player.gold >= offer.cost) {
                    if (offer.type === "potion" && player.potions >= player.maxPotions) {
                        addLog("You can't carry any more potions!");
                        return;
                    }
                    showPurchaseConfirmation(offer);
                } else if (offer && player.gold < offer.cost) {
                    addLog("Not enough Gold!");
                }
            });

            buyOffer2Button.addEventListener("click", () => {
                const offer = currentMerchantOffers[1];
                if (offer && offer.action && !offer.purchased && player.gold >= offer.cost) {
                    if (offer.type === "potion" && player.potions >= player.maxPotions) {
                        addLog("You can't carry any more potions!");
                        return;
                    }
                    showPurchaseConfirmation(offer);
                } else if (offer && player.gold < offer.cost) {
                    addLog("Not enough Gold!");
                }
            });

            leaveMerchantButton.addEventListener("click", () => {
                addLog("The merchant waves goodbye and disappears into the shadows.");
                toggleMerchantUI(false);
                toggleCombatUI(false); // Also ensure combat UI is reset if merchant was an interruption
            });

            document.addEventListener("keydown", function (event) {
                if (event.key === "Escape") {
                    if (purchaseConfirmationModalEl.style.display === "flex") {
                        // Prioritize closing confirmation modal
                        cancelPurchaseButtonEl.click();
                        event.preventDefault();
                        return;
                    } else if (helpModalEl && helpModalEl.style.display === "flex") {
                        helpModalEl.style.display = "none";
                        event.preventDefault();
                        return;
                    }
                }

                function isActionable(element) {
                    return element && element.style.display !== "none" && !element.disabled;
                }

                // Modal interactions first
                if (purchaseConfirmationModalEl.style.display === "flex") {
                    if (event.key === "Enter" && isActionable(confirmPurchaseButtonEl)) {
                        confirmPurchaseButtonEl.click();
                        event.preventDefault();
                        return;
                    }
                    if (event.key === "Backspace" && isActionable(cancelPurchaseButtonEl)) {
                        cancelPurchaseButtonEl.click();
                        event.preventDefault();
                        return;
                    }
                    // If in modal, don't process other keys generally
                    if (["Enter", "Backspace", "Escape"].includes(event.key)) return;
                }

                // Game Over screen
                if (gameOverScreenEl.style.display !== "none") {
                    if (event.key === "Enter" && isActionable(restartButton)) {
                        restartButton.click();
                        event.preventDefault();
                        return;
                    }
                    if (["Enter", "Escape"].includes(event.key)) return; // Only Enter and Escape on game over
                }

                // Combat actions
                if (inCombat) {
                    if (
                        (event.key === " " || event.code === "Space") &&
                        isActionable(attackButton)
                    ) {
                        attackButton.click();
                        event.preventDefault();
                    } else if (
                        (event.key === "d" || event.key === "D") &&
                        isActionable(defendButton)
                    ) {
                        defendButton.click();
                        event.preventDefault();
                    } else if (
                        (event.key === "p" || event.key === "P") &&
                        isActionable(potionButton)
                    ) {
                        potionButton.click();
                        event.preventDefault();
                    }
                    // If any combat key was processed or relevant, return
                    if (
                        [" ", "d", "D", "p", "P"].includes(event.key.toLowerCase()) ||
                        event.code === "Space"
                    )
                        return;
                }

                // Merchant actions (only if not in combat and purchase modal is hidden)
                if (inMerchantEncounter && purchaseConfirmationModalEl.style.display === "none") {
                    if (event.key === "1" && isActionable(buyOffer1Button)) {
                        buyOffer1Button.click();
                        event.preventDefault();
                    } else if (event.key === "2" && isActionable(buyOffer2Button)) {
                        buyOffer2Button.click();
                        event.preventDefault();
                    } else if (event.key === "3" && isActionable(leaveMerchantButton)) {
                        leaveMerchantButton.click();
                        event.preventDefault();
                    }
                    if (["1", "2", "3"].includes(event.key)) return;
                }

                // Explore button (if no other context took precedence)
                if (event.key === "Enter" && isActionable(exploreButton)) {
                    exploreButton.click();
                    event.preventDefault();
                    return;
                }
            });

            restartButton.addEventListener("click", resetGame);

            // Initialize game
            resetGame();
        </script>
    </body>
</html>
